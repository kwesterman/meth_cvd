---
title: MRS Model Experimentation
output:
  pdf_document:
    latex_engine: pdflatex
---

```{r prereqs, include=F, cache=F}
library(knitr)
opts_chunk$set(echo=F, cache=T, cache.lazy=F, cache.path="../cache/mrs_experiments/",
               fig.keep="high", fig.path="../output/figures/")
suppressMessages(silent <- lapply(c("tidyverse","survival","glmnet","minfi","caret","doParallel","itertools",
                                    "randomForest","pROC"), library, character.only=T))
```

```{r train-test-funcs}
train_mrs <- function(mod, meta, meth, trainset, 
                      alpha=0.5, nfolds=5, lmr=0.1, lambda.type="lambda.min", parallel=F) {
  covars_frame <- model.frame(as.formula(mod), meta, na.action=na.pass)  # To allow NAs to pass through
  covars_mat <- model.matrix(as.formula(mod), covars_frame)[,-1]  # Converts factors to numeric
  design_mat <- cbind(covars_mat, t(meth))
  cvd_surv <- Surv(time=meta$time, event=meta$event)  # Outcome
  mrs.fit.cv <- cv.glmnet(design_mat[trainset,], cvd_surv[trainset], family="cox", alpha=alpha,  # Train MRS model
                          penalty.factor=ifelse(grepl("^cg", colnames(design_mat)), 1, 0), 
                          nfolds=nfolds, lambda.min.ratio=lmr, parallel=parallel)
  coefs <- coef(mrs.fit.cv, s=lambda.type)
  cpgCoefs <- coefs[grepl("^cg", rownames(coefs)),]
  list(fit=mrs.fit.cv,  # Output is a list containing the model fit and the CpG model coefficients
       allCoefs=coefs,
       cpgCoefs=cpgCoefs)
}

calc_mrs <- function(coefs, meth) {
  if (length(coefs)==0 || all(coefs==0)) {
    message("No non-zero coefficients")
    return(rep(NA, ncol(meth)))
  } else {
    nonZeroCoefs <- coefs[coefs!=0]
    as.vector(t(meth[names(nonZeroCoefs),,drop=F]) %*% nonZeroCoefs)
  }
} 

test_mrs <- function(meta, mrs, testset) {
  meta$mrs <- scale(mrs)
  meta$cvd_surv <- Surv(time=meta$time, event=meta$event)  # Outcome
  mrs.test <- coxph(cvd_surv~mrs, data=meta, subset=testset) # Test the MRS using a Cox model
  mrs.res <- summary(mrs.test)$coef["mrs",c("exp(coef)","z")]
  tibble(HR_per_SD=mrs.res["exp(coef)"], p=as.character(2*pnorm(-abs(mrs.res["z"]))))
}

trainTestMRS <- function(mod, meta, meth, trainset, testset, alpha=0.5, nfolds=5, lmr=0.1, lt="lambda.min", parallel=F) {
  mrs_fit <- train_mrs(mod, meta, meth, trainset, alpha=alpha, nfolds=nfolds, lmr=lmr, lambda.type=lt, parallel=parallel)
  mrs_values <- calc_mrs(mrs_fit$cpgCoefs, meth)
  mrs_test <- tryCatch(test_mrs(meta, mrs_values, testset), error=function(e) matrix(NA, 1, 2))
  list(fit=mrs_fit, components=mrs_fit$cpgCoefs, values=mrs_values, res=mrs_test)
}
```

```{r load-data, cache=F, warning=F}
# Load methylation data
betas <- readRDS("../int/betas.qc.norm.filt.rds")  # Loads beta values object

# Load non-methylation (event + covariate) data
nonMethData <- readRDS("../int/nonMethData.rds")
nonMethData <- replace_na(nonMethData,  # Replace missing values (very few) with median
                          list(bmi=median(nonMethData$bmi, na.rm=T),
                               smk_now=median(nonMethData$smk_now, na.rm=T),
                               ht_med=median(nonMethData$ht_med, na.rm=T),
                               lipid_med=median(nonMethData$lipid_med, na.rm=T),
                               dm_med=median(nonMethData$dm_med, na.rm=T)))

# # Load ComBat-specific PCA
# load("../int/PCA_combat.RData")
# combat_PCs <- setNames(PCs, c("sampleKey", paste0("PC",1:20,"_combat")))
# nonMethData <- inner_join(nonMethData, combat_PCs, by="sampleKey")

# Make sure samples and their ordering are identical in methylation and metadata
betas <- betas[,match(nonMethData$sampleKey, colnames(betas))]
stopifnot(all(colnames(betas)==nonMethData$sampleKey))  # Ensure identical number and order of samples for methylation and covariate data

metaData <- readRDS("../int/metaData.rds")
fhsCPACOR <- readRDS("../int/cpacor.fit.fhs.rds")
fhsCPPCs <- setNames(cbind(metaData$sampleKey[metaData$study=="fhs"], data.frame(fhsCPACOR$x)),
                     c("sampleKey", paste0("cp", colnames(fhsCPACOR$x),"_indiv")))
whiCPACOR <- readRDS("../int/cpacor.fit.whi.rds")
whiCPPCs <- setNames(cbind(metaData$sampleKey[metaData$study=="whi"], data.frame(whiCPACOR$x)),
                     c("sampleKey", paste0("cp", colnames(whiCPACOR$x),"_indiv")))
allCPPCs <- rbind(fhsCPPCs, whiCPPCs)
nonMethData <- nonMethData %>% inner_join(allCPPCs, by="sampleKey")

whiSet <- which(nonMethData$study=="whi")
fhsSet <- which(nonMethData$study=="fhs")
```

# Preliminaries

* Currently using two datasets: FHS Offspring and WHI
* `r nrow(betas)` probes from the 450k array passed QC/filtering step
* `r length(fhsSet)` individuals from FHS, `r sum(nonMethData$event[fhsSet])` of whom have an incident event
* `r length(whiSet)` individuals from WHI, `r sum(nonMethData$event[whiSet])` of whom have an incident event

# EWAS for incident CVD

Performed in WHI. For reference, Tsai & Bell (2015) estimate that approximately 200 case-control pairs are required to have 80% power to identify a 7% methylation difference. 

```{r ewas-prep}
myTry <- function(expr, CpG) {
  # Captures model failures and returns successful result or vector of NAs
  tryCatch(expr,
           error = function(e) {print(e); return(c(CpG, rep(NA, 3)))},
           warning = function(w) {print(w); return(c(CpG, rep(NA, 3)))})
}

run_coxModel <- function(probeData, covarData, model_spec, subset) {
  # Given a row of the M-value matrix (corresponding to a CpG site), bind that methylation
  # data to the covariate data and run Cox proportional hazards regression
  CpG <- rownames(probeData)
  modelData <- cbind(covarData, meth=as.numeric(probeData),
                     survObj=Surv(time=covarData$time, event=covarData$event))
  myTry({
    cox.fit <- coxph(as.formula(model_spec), data=modelData, subset=subset)
    c(CpG=CpG, summary(cox.fit)$coef['meth',c('coef','z','Pr(>|z|)')])
  }, CpG)
}
```

```{r ewas-cpacorOnly}
cl <- makePSOCKcluster(detectCores())
registerDoParallel(cl)

ewasModel_cpacorOnly <- paste0("survObj~meth+",paste0("cpPC",1:10,"_indiv",collapse="+"))
ewasRes_cpacorOnly <- foreach(meth=iter(betas, by="row"), .packages="survival") %dopar%
  run_coxModel(meth, nonMethData, ewasModel_cpacorOnly, whiSet)

stopCluster(cl)

ewasResDF_cpacorOnly <- do.call(rbind, ewasRes_cpacorOnly) %>%
  data.frame(stringsAsFactors=F, check.names=F) %>%
  dplyr::rename(p=`Pr(>|z|)`) %>%
  mutate_at(c("coef","z","p"), as.numeric) %>%
  mutate(fdr=p.adjust(p, method="BH")) %>%
  arrange(p)
```

```{r ewas-fullAdjustment}
cl <- makePSOCKcluster(detectCores())
registerDoParallel(cl)

ewasModel_fullAdjustment <- paste0("survObj~meth+",paste0("cpPC",1:10,"_indiv",collapse="+"),
                                   "+age+race+bmi+smk_now+CD4T+CD8T+Bcell+NK+Mono+Gran")
ewasRes_fullAdjustment <- foreach(meth=iter(betas, by="row"), .packages="survival") %dopar%
  run_coxModel(meth, nonMethData, ewasModel_fullAdjustment, whiSet)

stopCluster(cl)

ewasResDF_fullAdjustment <- do.call(rbind, ewasRes_fullAdjustment) %>%
  data.frame(stringsAsFactors=F, check.names=F) %>%
  dplyr::rename(p=`Pr(>|z|)`) %>%
  mutate_at(c("coef","z","p"), as.numeric) %>%
  mutate(fdr=p.adjust(p, method="BH")) %>%
  arrange(p)
```

```{r ewas-inflation, cache=F, fig.show="hold", out.width="50%"}
make_qqplot <- function(pVec, plotTitle="Title") {
  pVec <- pVec[!is.na(pVec)]
  qqplot(-log10(1:length(pVec)/length(pVec)), -log10(pVec), pch=".", main=plotTitle, xlab="Expected (-logP)", ylab="Observed (-logP)")
  abline(0,1,col="red")
}
gControl <- function(pVals) {
# See van Iterson 2017 methods and/or Lehne 2015 code for details on genomic control for EWAS
# Below is modeled after Lehne 2015
lambda <- median(qchisq(pVals, df=1, lower.tail=F), na.rm=T)/qchisq(0.5, df=1)
round(lambda, 2)
}

make_qqplot(ewasResDF_cpacorOnly$p, plotTitle=paste0("EWAS: adj. for 10 ctrl probe PCs only (lambda = ", gControl(ewasResDF_cpacorOnly$p), ")"))
make_qqplot(ewasResDF_fullAdjustment$p, plotTitle=paste0("EWAS: adj. for 10 ctrl probe PCs + basic covars + WBC counts\n(lambda = ", gControl(ewasResDF_fullAdjustment$p), ")"))
```

Using the adjusted results, a gene set enrichment analysis was performed in the following manner:

1. Collect the set of CpGs with FDR<0.2 in EWAS
1. Assign CpGs to genes based on the available Illumina 450k annotation
2. Test for enrichment using the GOseq package, which explicitly accounts for RNA-seq length bias but can be co-opted to account for bias in number of probes per gene (Geeleher 2013)

```{r gsea, message=F, warning=F}
suppressMessages(silent <- lapply(c("goseq","IlluminaHumanMethylation450kanno.ilmn12.hg19"), 
                                  library, character.only=T))
anno450k <- data.frame(getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19), stringsAsFactors=F) 

cpg_to_gene <- anno450k %>%
  dplyr::rename(cpg=Name, gene=UCSC_RefGene_Name) %>%
  dplyr::select(cpg, gene) %>%
  separate_rows(gene, sep=";") %>%
  distinct() %>%
  filter(gene!="")
gene_numbers <- cpg_to_gene %>%
  group_by(gene) %>%
  summarise(nCpGs=n())

topCpGs <- ewasResDF_fullAdjustment$CpG[ewasResDF_fullAdjustment$fdr<0.2]
topGenes <- unique(cpg_to_gene$gene[cpg_to_gene$cpg %in% topCpGs])
DMgenes <- setNames(gene_numbers$gene %in% topGenes, gene_numbers$gene)
pwf <- nullp(DMgenes, "hg19", "geneSymbol", bias.data=gene_numbers$nCpGs, plot.fit=F)

# msigdb_file <- file("../data/misc/gsea/c2.cp.v6.0.symbols.gmt")  # MSigDB file from http://software.broadinstitute.org/gsea/msigdb/collections.jsp#C2
# msigdb <- strsplit(readLines(msigdb_file), split="\t")  # File is tab-separated with gene lists immediately following their names and URLs
# names(msigdb) <- purrr::map(msigdb, 1)  # First element of each msig vector is name
# msigdb <- purrr::map(msigdb, function(sig) sig[-c(1,2)])  # No need for name or URL
# gene2cat <- data.frame(gene=unlist(msigdb), cat=rep(names(msigdb), times=lengths(msigdb)))

GO.wall <- goseq(pwf, "hg19", "geneSymbol")
GO.out <- GO.wall %>%
  mutate(fdr=p.adjust(over_represented_pvalue, method="BH")) %>%
  dplyr::arrange(fdr) %>%
  dplyr::select(term, ontology, numDEInCat, numInCat, over_represented_pvalue, fdr) %>%
  dplyr::slice(1:20)

GO.out$term <- strtrim(GO.out$term, 40)

kable(GO.out, caption="GO-based gene set enrichment testing")
```

# Initial MRS model selection

## Choice of input CpG set

Models below are trained in WHI and the results from testing in FHS are shown. For now, EWAS-related models use *unadjusted* associations (only control-probe PCs). Regressions are adjusted only for control-probe principal components, but no biological covariates.

```{r ewas-mrs, dependson=c("ewas-cpacorOnly","ewas-fullAdjustment")}
ewasResDF <- ewasResDF_cpacorOnly ## FOR NOW, ADDRESS THIS LATER?

cpgNum <- c(25,50,100,250,500,1000)
ewasMrsWeightedSum <- lapply(cpgNum, function(num) {
  mrs_coefs <- setNames(ewasResDF[seq(1,num),"coef"], ewasResDF[seq(1,num),"CpG"])
  mrs_calc <- calc_mrs(mrs_coefs, betas)
  mrs_test <- test_mrs(nonMethData, mrs_calc, fhsSet)
  mrs_test
  # t(as.matrix(mrs_test)) # Outputs 1x2 matrix
})
ewasMrsWeightedSumDF <- do.call(rbind, ewasMrsWeightedSum) %>%
  mutate(numberOfCpGsUsed=cpgNum)

cpacor_adj_model <- paste0("~",paste0("cpPC",1:10,"_indiv",collapse="+"))
ewasMrsEnet.list <- lapply(cpgNum, function(num) {
  topCpGs <- ewasResDF$CpG[seq(1,num)]
  trainTestMRS(cpacor_adj_model, nonMethData, betas[topCpGs,], whiSet, fhsSet)
})
ewasMrsEnetDF <- do.call(rbind, purrr::map(ewasMrsEnet.list, "res")) %>%
  data.frame(stringsAsFactors=F, check.names=F) %>%
  mutate(numberOfCpGsUsed=cpgNum)
```

```{r variance-thresholds, message=F}
cpacor_adj_model <- paste0("~",paste0("cpPC",1:10,"_indiv",collapse="+"))

beta_variances <- apply(betas[,whiSet], 1, var)  # Get variances only in training set

cl <- makePSOCKcluster(4)
registerDoParallel(cl)

varThreshQuantiles <- c(0.25,0.5,0.75,0.9)
varRes.list <- lapply(varThreshQuantiles, function(vtq) {
  trainTestMRS(cpacor_adj_model, nonMethData, betas[beta_variances>quantile(beta_variances,vtq),], 
               whiSet, fhsSet, parallel=T)
})

stopCluster(cl)

varResDF <- do.call(rbind, purrr::map(varRes.list, "res")) %>%
  data.frame(stringsAsFactors=F, check.names=F) %>%
  mutate(varThreshold_percent=varThreshQuantiles)
```

```{r cvd-snp-mrs, message=F}
library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
anno450k <- data.frame(getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19), stringsAsFactors=F)
cvd_gwas_associations <- read_tsv("../data/literature/gwas-association-downloaded_2017-09-18-cardiovascular disease.tsv")
cvd_gwas_cpgs_byPos <- cvd_gwas_associations %>%
  mutate(chr=paste0("chr", CHR_ID),
         snp_pos=CHR_POS) %>%
  select(chr, snp_pos) %>%
  inner_join(select(anno450k, Name, chr, pos), by="chr") %>%
  mutate(snp_pos=as.numeric(snp_pos)) %>%
  filter(pos>=snp_pos-1000, pos<=snp_pos+1000) %>%
  dplyr::rename(cpg=Name) %>%
  distinct(cpg)
cvd_cpgs <- cvd_gwas_cpgs_byPos$cpg
cvdModel <- trainTestMRS(cpacor_adj_model, nonMethData, betas[rownames(betas) %in% cvd_cpgs,], whiSet, fhsSet)
cvdRes <- cvdModel$res
```

```{r display-cpg-set-comparison, cache=F, dependson=c("ewas-mrs","variance-thresholds","cvd-snp-mrs"), out.width="80%"}

kable(mutate(ewasMrsWeightedSumDF, p=as.character(format(p,digits=3))), caption="Using direct weights from EWAS")
# ggplot(ewasMrsWeightedSumDF, aes(x=numberOfCpGsUsed, y=HR_per_SD)) + 
#   geom_point() + 
#   geom_line() +
#   ylab("Estimated HR per SD") +
#   ggtitle("Using direct weights from EWAS")

kable(mutate(ewasMrsEnetDF, p=as.character(format(p,digits=3))), caption="Using top CpGs from EWAS as input to elastic net")
# ggplot(ewasMrsEnetDF, aes(x=numberOfCpGsUsed, y=HR_per_SD)) + 
#   geom_point() + 
#   geom_line() +
#   ylab("Estimated HR per SD") +
#   ggtitle("Using top CpGs from EWAS as input to elastic net")

kable(mutate(cvdRes, p=as.character(format(p,digits=3))), caption="Using ~1k CpGs near CVD GWAS loci as input to elastic net")

kable(mutate(varResDF, p=as.character(format(p,digits=3))), caption="Using a naive CpG variance threshold before running elastic net")
# ggplot(varResDF, aes(x=varThreshold_percent, y=HR_per_SD)) + 
#   geom_point() + 
#   geom_line() +
#   xlab("Variance threshold (quantile)") +
#   ylab("Estimated HR per SD") +
#   ggtitle("Using a naive CpG variance threshold before running elastic net")
```

The direct weighted sum from EWAS shows the highest estimated HRs, but the significance is not quite as strong as that from the "naive" elastic net regression. Using these EWAS CpGs as input to a regression seems to be much worse, but one might expect the algorithm to overfit/insufficiently penalize the coefficients since the CpG set was found in the entire training set (WHI) -- I have confirmed that manually increasing the penalty parameter can increase the predictive significance to a level greater than the weighted sum. Likewise, the CVD biology-based CpG set over-penalizes the coefficients because it doesn't take into account the higher likelihood that this biologically motivated feature set is a priori more likely to generalize. Using naive variance thresholds before regression shows solid performance, so the 75% threshold (top 25% most variable CpGs) will be used moving forward to compromise between performance and computational requirements.

## Evaluation

(Using the 75th quantile variance threshold CpG set elastic net model)

```{r evaluation, cache=F}
source("helpers.R")

run_mrs_lr <- function(dat, mrs_values) {
  dat$mrs <- scale(mrs_values)
  dat <- dat %>%
    mutate(diabetes=dm_med|glu>125) %>%
    replace_na(list(diabetes=F))
  dat$frs <- calc_FRS(dat)
  testset <- which(dat$study=="fhs" & !is.na(dat$frs))
  mrs_only <- glm(event~mrs, data=dat, subset=testset)
  frs_only <- glm(event~frs, data=dat, subset=testset)
  combined <- glm(event~mrs+frs, data=dat, subset=testset)
  list(mrs=mrs_only, frs=frs_only, combined=combined, testset=testset)
}

lr_res <- run_mrs_lr(nonMethData, varRes.list[[3]]$values)
library(pROC)
mrsROC <- roc(nonMethData$event[lr_res$testset], predict(lr_res$mrs))
plot(mrsROC, col="red")
frsROC <- roc(nonMethData$event[lr_res$testset], predict(lr_res$frs))
plot(frsROC, col="blue", add=T)
combinedROC <- roc(nonMethData$event[lr_res$testset], predict(lr_res$combined))
plot(combinedROC, col="green", add=T)
legend("bottomright", legend=paste0(c("MRS: auc=","FRS: auc=","MRS+FRS: auc="), 
                                    round(as.numeric(c(mrsROC$auc, frsROC$auc, combinedROC$auc)), 2)), 
                                    col=c("blue","red","green"), lty=1, lwd=3, cex=1.3)
```

For appropriate comparison to the Framingham Risk Score, the evaluation here is based on a binary classification of whether an incident event did or did not occur. The basic MRS shows a reasonable c-statistic (ROC area under the curve) of 0.66, comparable to that of my implementation of the FRS algorithm. There seems to be a bit of synergy between the two risk scores, as performance increases slightly when using them together. One important caveat is that the FRS is generally estimated to show a c-statistic closer to 0.75, so it is possible that FHS Offspring is not an optimal test cohort (because cholesterol is not predictive of CVD risk in this population?) or that there is some error in my coding of the FRS.

## Are the patterns identified specific to a population subset?

(Using the 75th quantile variance threshold CpG set elastic net model)

```{r population-subsets}
maleTest <- test_mrs(nonMethData, varRes.list[[3]]$values, 
                     which(nonMethData$study=="fhs" & nonMethData$sex=="M"))
femaleTest <- test_mrs(nonMethData, varRes.list[[3]]$values,
                       which(nonMethData$study=="fhs" & nonMethData$sex=="F"))
sexSpecificRes <- as.data.frame(rbind(maleTest,femaleTest)) %>%
  mutate(sex=c("Male","Female"))

pastEventsOnlyTest <- test_mrs(nonMethData, varRes.list[[3]]$values, 
                               which(nonMethData$study=="fhs" & nonMethData$pastEvent==T))
noPastEventsTest <- test_mrs(nonMethData, varRes.list[[3]]$values, 
                             which(nonMethData$study=="fhs" & nonMethData$pastEvent==F))
pastEventSpecificRes <- as.data.frame(rbind(pastEventsOnlyTest, noPastEventsTest)) %>%
  mutate(pastEvent=c("Yes","No"))
```

Though the MRS above is trained in a female-only cohort, there is no evidence here of any bias of the MRS towards predicting events in females. Based on previous results, there was also reason to believe that prior CVD could be an important confounder -- this could manifest as a much better performance of the classifier in those who experienced prior CVD events, but there doesn't seem to be any such effect here.

```{r display-population-subsets, dependson="population-subsets"}
kable(mutate(sexSpecificRes, p=as.character(format(p,digits=3))), caption="Stratify by sex")
kable(mutate(pastEventSpecificRes, p=as.character(format(p,digits=3))), caption="Stratify by whether FHS subjects experienced a past CVD event")
```

# Exploration of model variants

To facilitate exploration of binary classifiers, testing from this point on uses logistic regression/odds ratios to evaluate MRS performance rather than Cox regression/hazard ratios. The CpG set used is still the 75th quantile variance threshold set.

```{r binary-funcs}
train_mrs_binary <- function(mod, meta, meth, trainset, 
                             alpha=0.5, nfolds=5, lmr=0.1, lambda.type="lambda.min", parallel=F) {
  covars_frame <- model.frame(as.formula(mod), meta, na.action=na.pass)  # To allow NAs to pass through
  covars_mat <- model.matrix(as.formula(mod), covars_frame)[,-1]  # Converts factors to numeric
  design_mat <- cbind(covars_mat, t(meth))
  eventVec <- factor(meta$event)
  mrs.fit.cv <- cv.glmnet(design_mat[trainset,], eventVec[trainset], family="binomial", alpha=alpha,
                          penalty.factor=ifelse(grepl("^cg", colnames(design_mat)), 1, 0), 
                          nfolds=nfolds, lambda.min.ratio=lmr, parallel=parallel)
  coefs <- coef(mrs.fit.cv, s=lambda.type)
  cpgCoefs <- coefs[grepl("^cg", rownames(coefs)),]
  list(fit=mrs.fit.cv,  # Output is a list containing the model fit and the CpG model coefficients
       allCoefs=coefs,
       cpgCoefs=cpgCoefs)
}

test_mrs_binary <- function(meta, mrs, testset) {
  meta$mrs <- scale(mrs)
  mrs.test <- glm(event~mrs, data=meta, family="binomial", subset=testset) # Test the MRS using a Cox model
  res <- summary(mrs.test)$coef["mrs",c("Estimate","Pr(>|z|)")]  # Outputs a vector
  tibble(OR_per_SD=exp(res["Estimate"]), p=res["Pr(>|z|)"])
}

trainTestMRS_binary <- function(mod, meta, meth, trainset, testset, alpha=0.5, nfolds=5, lmr=0.1, lt="lambda.min", parallel=F) {
  mrs_fit <- train_mrs_binary(mod, meta, meth, trainset, 
                              alpha=alpha, nfolds=nfolds, lmr=lmr, lambda.type=lt, parallel=parallel)
  mrs_values <- calc_mrs(mrs_fit$cpgCoefs, meth)
  mrs_test <- tryCatch(test_mrs_binary(meta, mrs_values, testset), error=function(e) matrix(NA, 1, 2))
  list(fit=mrs_fit, components=mrs_fit$cpgCoefs, values=mrs_values, res=mrs_test)
}
```

```{r binary-test-baseline}
binTestOnlyRes <- test_mrs_binary(nonMethData, varRes.list[[3]]$values, fhsSet)
```

```{r binary-mrs, dependson="binary-funcs"}
cl <- makePSOCKcluster(4)
registerDoParallel(cl)
binaryModel <- trainTestMRS_binary(cpacor_adj_model, nonMethData, 
                                   logit2(betas[beta_variances>quantile(beta_variances,0.75),]),
                                   whiSet, fhsSet, parallel=T)
stopCluster(cl)

binaryRes <- binaryModel$res
```

```{r display-binary-tests, dependson=c("binary-test-baseline","binary-mrs")}
kable(mutate(binTestOnlyRes, p=as.character(format(p,digits=3))), caption="Test the same 75th quantile MRS from above for binary CVD event outcome")
kable(mutate(binaryRes, p=as.character(format(p,digits=3))), caption="Training and testing using a binary outcome")
```

```{r Mvals}
cl <- makePSOCKcluster(4)
registerDoParallel(cl)
mvalModel <- trainTestMRS(cpacor_adj_model, nonMethData, 
                          logit2(betas[beta_variances>quantile(beta_variances,0.75),]),
                          whiSet, fhsSet, parallel=T)
stopCluster(cl)

mvalRes_binTest <- test_mrs_binary(nonMethData, mvalModel$values, fhsSet)
```

```{r display-Mvals}
kable(mutate(mvalRes_binTest, p=as.character(format(p,digits=3))), caption="Using M-values instead of beta values")
```

```{r random-forest, message=F}
testTrain_RF <- function(mod, meta, meth, trainset, testset, ntree, ncores, seed=1) {
  set.seed(seed)
  covars_frame <- model.frame(as.formula(mod), meta, na.action=na.pass)  # To allow NAs to pass through
  covars_mat <- model.matrix(as.formula(mod), covars_frame)[,-1]  # Converts factors to numeric
  design_mat <- t(meth)
  rf.fit <- foreach(nt=rep(ntree/ncores,ncores), .combine=randomForest::combine, .packages="randomForest") %dopar%
    randomForest(design_mat[trainset,], factor(meta$event)[trainset], ntree=nt)
  rf_mrs <- predict(rf.fit, newdata=design_mat, type="prob")[,"TRUE"]
  rf_test <- test_mrs(meta, rf_mrs, testset)
  list(res=rf_test, fit=rf.fit, values=rf_mrs)
}

cl <- makePSOCKcluster(8)
registerDoParallel(cl)
rfModel <- testTrain_RF(cpacor_adj_model, nonMethData, betas[beta_variances>quantile(beta_variances,0.75),], 
                        whiSet, fhsSet, ntree=80*8, ncores=8)
stopCluster(cl)

rfRes <- rfModel$res
```

```{r display-rf}
# Hack for now
rfRes <- test_mrs_binary(nonMethData, rfModel$values, fhsSet) %>%
  mutate(p=as.character(format(p,digits=3)))
kable(rfRes, caption="Random forest model")
```

The first two tables above compare models that are both tested using binary classifiers, but one is trained using a Cox model while the other is trained through a logistic model. As might be expected, a notable increase in performance is achieved by the Cox model, as it is able to take advantage of additional time-to-event information.

Performance of the full training and testing procedure using M-values does not seem to improve performance.

A random forest model trained on the same set of CpGs and a binary event outcome shows a comparably high OR, but the p-value doesn't indicate notable predictive ability -- what is going on here? To investigate, here are the distributions of the probabilities output by the random forest algorithm (used here as the MRS).

```{r rf-mrs-distributions, cache=F, fig.show="hold", out.width="50%"}
hist(rfModel$values[whiSet], main="RF prob. distribution (training set)")
hist(rfModel$values[fhsSet], main="RF prob. distribution (test set)")
hist(varRes.list[[3]]$values[whiSet], main="Regression-based MRS distribution in training \nset, for comparison ")
```

Clearly, the random forest is overfitting -- it is way too good at classifying incident events in the training set. Likely it is identifying WHI-specific population specific or batch effects, especially since I was not able to adjust for control probe PCs in the random forest model training. So, it may be helpful to combine my two datasets before creating a train-test split in order to mitigate these population-specific patterns.

## Cross-cohort training

Here, the populations were combined and the full dataset was randomly divided into a 70/30 train/test split, while ensuring proportional numbers of incident events in each set.

```{r train-test-split}
set.seed(1)
trainset <- createDataPartition(factor(nonMethData$event), p=0.7)[[1]]
testset <- seq(1,nrow(nonMethData))[-trainset]
```

```{r enet-combined}
beta_variances_trainset <- apply(betas[,trainset], 1, var)

cl <- makePSOCKcluster(5)
registerDoParallel(cl)
enetCombined <- trainTestMRS(cpacor_adj_model, nonMethData, 
                              betas[beta_variances_trainset>quantile(beta_variances_trainset,0.75),],
                              trainset, testset, parallel=T)
stopCluster(cl)

enetCombined_binTest <- test_mrs_binary(nonMethData, enetCombined$values, testset)
```

```{r rf-combined}
cl <- makePSOCKcluster(8)
registerDoParallel(cl)
rfModelCombined <- testTrain_RF(cpacor_adj_model, nonMethData, 
                                betas[beta_variances_trainset>quantile(beta_variances_trainset,0.75),], 
                                trainset, testset, ntree=80*8, ncores=8)
stopCluster(cl)

rfResCombined <- rfModelCombined$res
```

```{r display-combined-models}
sep_vs_combined_regression <- rbind(binTestOnlyRes, enetCombined_binTest) %>%
  mutate(model=c("WHI train, FHS test","Combined 70/30 split"),
         p=as.character(format(p,digits=3)))
kable(sep_vs_combined_regression, caption="Elastic net regression")

## For now....
rfCombined_binTest <- test_mrs_binary(nonMethData, rfModelCombined$values, testset)

sep_vs_combined_rf <- rbind(rfRes, rfCombined_binTest) %>%
  mutate(model=c("WHI train, FHS test","Combined 70/30 split"),
         p=as.character(format(p,digits=3)))
kable(sep_vs_combined_rf, caption="Random forest")
```

### Evaluation of cross-cohort trained models

```{r evaluate-combined-models, cache=F, out.width="50%"}
library(pROC)

enetROC <- roc(nonMethData$event[testset], enetCombined$values[testset])
plot(enetROC, print.auc=T, main="Regression-based MRS")

rfROC <- roc(nonMethData$event[testset], rfModelCombined$values[testset])
plot(rfROC, print.auc=T, main="Random forest-based MRS")
```

### Is this model fitting only dataset-specific patterns?

Try to evaluate this by fitting separate models in WHI and FHS.

```{r dataset-specific}
fhsMeta <- nonMethData[fhsSet,]
set.seed(1)
fhsTrain <- createDataPartition(factor(fhsMeta$event), p=0.7)[[1]]
fhsTest <- seq(1,nrow(fhsMeta))[-fhsTrain]
beta_variances_fhsTrain <- apply(betas[,fhsSet[fhsTrain]], 1, var)
cl <- makePSOCKcluster(5)
registerDoParallel(cl)
dsFHSModel <- trainTestMRS(cpacor_adj_model, fhsMeta, 
                           betas[beta_variances_fhsTrain>quantile(beta_variances_fhsTrain,0.75),fhsSet], 
                           fhsTrain, fhsTest, parallel=T)
dsFHSRes <- test_mrs_binary(fhsMeta, dsFHSModel$values, fhsTest)
stopCluster(cl)

whiMeta <- nonMethData[whiSet,]
set.seed(1)
whiTrain <- createDataPartition(factor(whiMeta$event), p=0.7)[[1]]
whiTest <- seq(1,nrow(whiMeta))[-whiTrain]
beta_variances_whiTrain <- apply(betas[,whiSet[whiTrain]], 1, var)
cl <- makePSOCKcluster(5)
registerDoParallel(cl)
dsWHIModel <- trainTestMRS(cpacor_adj_model, whiMeta, 
                           betas[beta_variances_whiTrain>quantile(beta_variances_whiTrain,0.75),whiSet], 
                           whiTrain, whiTest, parallel=T)
dsWHIRes <- test_mrs_binary(whiMeta, dsWHIModel$values, whiTest)
stopCluster(cl)
```

```{r display-dataset-specific}
kable(dsFHSRes, caption="Train and test in FHS only")
kable(dsWHIRes, caption="train and test in WHI only")
```

Though ideally there would be a fully independent validation set available, the mediocre within-cohort cross-validation results don't indicate any population-specific effects of a strength that would dominate the above combined regression results.

# Biological significance of the MRS

## Biological covariates

The intent to this point was to determine the "maximum predictive power" of microarray-based methylation data in predicting CVD events. However, known associations of methylation with sex, age, white blood cell proportions, etc. may explain a substantial fraction of this predictive power. 

```{r biological-significance, cache=F}
wbcCounts <- dplyr::select(nonMethData, CD4T, CD8T, Bcell, NK, Mono, Gran)
nonMethData$wbcPC1 <- prcomp(wbcCounts, scale.=T)$x[,1]
nonMethData$wbcPC2 <- prcomp(wbcCounts, scale.=T)$x[,2]

singleCovs <- c("sex","age","bmi","wbcPC1","wbcPC2","smk_now","ht_med","lipid_med","dm_med")
covs <- c("none", singleCovs, paste0(singleCovs, collapse="+"))
names(covs) <- c(covs[1:(length(covs)-1)], "all")
negLogPs <- lapply(covs, function (covSet) {
  mrs <- enetCombined$values
  form <- if (covSet=="none") as.formula("event~mrs") else as.formula(paste0("event~mrs+",covSet))
  mrsCovs.fit <- glm(form, family="binomial", data=nonMethData, subset=testset)
  negLogP <- -log10(2*pnorm(-abs(summary(mrsCovs.fit)$coef["mrs","z value"])))
  negLogP
})

negLogPs.df <- data.frame(covariate=factor(names(covs), levels=names(covs)), negLogP=unlist(negLogPs))

ggplot(negLogPs.df, aes(x=covariate, y="", fill=negLogP)) + 
  geom_tile() +
  scale_fill_gradient2(low='#0000FF',mid='#FFFFFF',high='#FF0000') +
  coord_fixed(ratio=1) +
  ggtitle("P-values for MRS after adjustment for covariate(s)") +
  theme(axis.title=element_blank(), axis.text.x=element_text(angle=30))

nonMethData$mrs <- enetCombined$values
mrsResids <- lm(as.formula(paste0("mrs~",covs["all"])), data=nonMethData)$residuals
adjROC <- roc(nonMethData$event[testset], mrsResids[testset])
```

The AUC of MRS residuals after adjustment for the full set of covariates above is `r round(auc(adjROC),2)`.

## Specific CpG components/weights

```{r cpg-literature}
cpg_custom_annotations <- c(
  cg09741592="smoking",
  cg18181703="metabolic syndrome",
  cg00534468="cholesterol efflux capacity",
  cg16867657="aging (strongly)",
  cg19693031="T2D",
  cg00854392="high-fat overfeeding in subQ AT",
  cg23287661="T2D in AT",
  cg23289079="cancer"
)
cpg_custom_annotations_DF <- tibble(CpG=names(cpg_custom_annotations), "Literature association"=cpg_custom_annotations)
```

```{r mrs-components}
components <- enetCombined$components
components <- components[components!=0]
componentsDF <- tibble(CpG=names(components), weight=components) %>%
  inner_join(cpg_to_gene, by=c("CpG"="cpg")) %>%
  left_join(cpg_custom_annotations_DF, by="CpG") %>%
  replace_na(list(`Literature association`="")) %>%
  arrange(desc(abs(weight)))
kable(componentsDF, caption="MRS components CpGs and associated genes")
```

## ...the catch, or "Batch effects: 1, Kenny: 0"

```{r 2enet-combined, eval=F}
cl <- makePSOCKcluster(5)
registerDoParallel(cl)
cpacor_adj_model_withStudy <- paste0(cpacor_adj_model, "+study")
TwoenetCombined <- trainTestMRS(cpacor_adj_model_withStudy, nonMethData, 
                              betas[beta_variances_trainset>quantile(beta_variances_trainset,0.75),],
                              trainset, testset, parallel=T)
stopCluster(cl)

TwoenetCombined_binTest <- test_mrs_binary(nonMethData, TwoenetCombined$values, testset)
```

```{r study-adjust}
mrsStudyResids <- lm(mrs~study, data=nonMethData)$residuals
studyAdjROC <- roc(nonMethData$event[testset], mrsStudyResids[testset])
```

It seems that I eventually got bitten by the class imbalance between FHS (mostly controls) and WHI (half cases) -- MRS residuals after adjustment for study lose much of their predictive power (AUC = `r studyAdjROC$auc`).

<!---# Alternate prediction strategies--->

```{r gene-set-activations, cache.vars=c("msigdb","sig_to_cpgs","pca_from_cpgSet","geneSetLoadings","geneSetActivationsMat")}
msigdb_file <- file("../data/misc/gsea/c2.cp.v6.0.symbols.gmt")  # MSigDB file from http://software.broadinstitute.org/gsea/msigdb/collections.jsp#C2
msigdb <- strsplit(readLines(msigdb_file), split="\t")  # File is tab-separated with gene lists immediately following their names and URLs
names(msigdb) <- purrr::map(msigdb, 1)  # First element of each msig vector is name
msigdb <- purrr::map(msigdb, function(sig) sig[-c(1,2)])  # No need for name or URL

genes_to_cpgs_df <- anno450k %>%
  dplyr::rename(gene=UCSC_RefGene_Name, cpg=Name) %>%
  dplyr::select(gene, cpg) %>%
  separate_rows(gene, sep=";") %>%
  distinct() %>% 
  filter(!is.na(gene), gene!="") %>%
  nest(-gene) %>%
  mutate(cpgs=purrr::map(data, function(d) unique(d$cpg))) %>%
  dplyr::select(-data)
genes_to_cpgs <- setNames(genes_to_cpgs_df$cpgs, genes_to_cpgs_df$gene)  # List of associated CpGs on 450k array for each gene

sig_to_cpgs <- purrr::map(msigdb, function(sig) unique(unlist(genes_to_cpgs[sig])))

library(flashpcaR)

pca_from_cpgSet <- function(cpgs, testset) {
  cpgs_trimmed <- cpgs[cpgs %in% rownames(betas)]
  pcaMat <- t(betas[cpgs_trimmed,testset])
  pca.fit <- flashpca(pcaMat, stand="sd", ndim=2, do_loadings=T)
  pc1_loadings <- pca.fit$loadings[,1]
  setNames(pc1_loadings, cpgs_trimmed)
}

geneSetLoadings <- lapply(sig_to_cpgs, pca_from_cpgSet, testset)

t_betas_scaled <- scale(t(betas))
geneSetActivations <- lapply(geneSetLoadings, function(loading) t_betas_scaled[,names(loading)] %*% loading)
geneSetActivationsMat <- do.call(cbind, geneSetActivations)
colnames(geneSetActivationsMat) <- names(geneSetActivations)
```

```{r gene-set-mrs, include=F}
stopifnot(all(rownames(geneSetActivationsMat)==nonMethData$sampleKey))
design_mat <- geneSetActivationsMat
cvd_surv <- Surv(time=nonMethData$time, event=nonMethData$event)
geneset.fit.cv <- cv.glmnet(design_mat[trainset,], cvd_surv[trainset], family="cox", alpha=0.5,  # Train MRS model
                            penalty.factor=ifelse(colnames(design_mat) %in% names(sig_to_cpgs), 1, 0), nfolds=5)
coefs <- coef(geneset.fit.cv, s="lambda.min")[,1]
coefs_meth <- coefs[coefs!=0 & (names(coefs) %in% names(sig_to_cpgs))]  # Methylation coefficients only
geneset_mrs_calc <- as.vector(design_mat[,names(coefs_meth)] %*% coefs_meth)  # Calculate the MRS for all samples
mrs.test <- test_mrs_binary(nonMethData, geneset_mrs_calc, testset)
print(mrs.test)
```

```{r gene-set-rf, include=F}
cl <- makePSOCKcluster(8)
registerDoParallel(cl)
rfGeneSetModel <- testTrain_RF(cpacor_adj_model, nonMethData, t(geneSetActivationsMat), 
                        trainset, testset, ntree=80*8, ncores=8)
stopCluster(cl)

geneSetRF_binTest <- test_mrs_binary(nonMethData, rfGeneSetModel$values, testset)
print(geneSetRF_binTest)
```









<!---
# Below is old stuff


## Hypothesis-driven CpG sets based on WBC biology

```{r hypothesis-driven, eval=F}
# See how pre-selection of specific CpG sets affects model performance
print("Test pre-selected CpG sets with biological relevance...")
library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
mon_to_mac <- suppressWarnings(read_csv("../data/literature/mon_to_mac_DMRs_Wallner2016.csv")) %>%
  filter(!is.na(Location)) %>%
  mutate(chr=gsub(":.*", "", Location),
         start=as.integer(gsub("-.*", "", gsub(".*:", "", Location))),
         end=as.integer(gsub(".*-", "", Location))) %>%
  select(chr, start, end)

mon_var_schroder <- read_csv("../data/literature/variable_monocyte_DMRs_Schroder2017.csv") %>%
  mutate(chr=paste0("chr", gsub(":.*", "", location)),
         start=as.integer(gsub("-.*", "", gsub(".*:", "", location))),
         end=as.integer(gsub(".*-", "", location))) %>%
  select(chr, start, end)

cpgAnnot <- Locations %>%
  data.frame(stringsAsFactors=F) %>%
  rownames_to_column(var="cpg")

mon_to_mac_cpgs <- inner_join(cpgAnnot, mon_to_mac, by="chr") %>%
  filter(pos>=start, pos<=end)

mon_var_schroder_cpgs <- inner_join(cpgAnnot, mon_var_schroder, by="chr") %>%
  filter(pos>=start, pos<=end)

# Read in Ecker variable CpGs (more than one sheet, each separately)
library(readxl)
variable_monSpecific <- read_excel("../data/literature/variable_cpgs_Ecker2017.xlsx", sheet="Monocytes")
variable_neutSpecific <- read_excel("../data/literature/variable_cpgs_Ecker2017.xlsx", sheet="Neutrophils")
variable_tcellSpecific <- read_excel("../data/literature/variable_cpgs_Ecker2017.xlsx", sheet="T cells")
variable_monNeutSpecific <- read_excel("../data/literature/variable_cpgs_Ecker2017.xlsx",
                                       sheet="Monocytes + neutrophils")

# CVD GWAS SNP-based
library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
anno450k <- data.frame(getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19), stringsAsFactors=F)
cvd_gwas_associations <- read_tsv("../data/literature/gwas-association-downloaded_2017-09-18-cardiovascular disease.tsv")
cvd_gwas_genes <- unique(unlist(strsplit(cvd_gwas_associations$`REPORTED GENE(S)`, split=", ")))

cvd_gwas_cpgs_byPos <- cvd_gwas_associations %>%
    mutate(chr=paste0("chr", CHR_ID),
         snp_pos=CHR_POS) %>%
  select(chr, snp_pos) %>%
  inner_join(select(anno450k, Name, chr, pos), by="chr") %>%
  mutate(snp_pos=as.numeric(snp_pos)) %>%
  filter(pos>=snp_pos-1000, pos<=snp_pos+1000) %>%
  dplyr::rename(cpg=Name) %>%
  distinct(cpg)

cvd_gwas_cpgs_byGene <- anno450k %>%
  filter(toupper(UCSC_RefGene_Name) %in% cvd_gwas_genes) %>%
  dplyr::rename(cpg=Name) %>%
  distinct(cpg)

trainTest_cpgSet <- function(cpgSet, cpgSetName) {
  print(paste0(cpgSetName, " (", length(cpgSet), " CpGs)"))
  kable(trainTestMRS(cpacor_adj_model, nonMethData, betas[rownames(betas) %in% cpgSet,],
                     whiSet, fhsSet)$res)
}

trainTest_cpgSet(mon_to_mac_cpgs$cpg, "Monocyte-to-macrophage DMRs, Wallner 2016")
trainTest_cpgSet(mon_var_schroder_cpgs$cpg, "Variable CpGs in monocytes, Schroder 2017")
trainTest_cpgSet(variable_monSpecific$`Probe ID`, "Variable CpGs in monocytes only, Ecker 2017")
trainTest_cpgSet(variable_neutSpecific$`Probe ID`, "Variable CpGs in neutrophils only, Ecker 2017")
trainTest_cpgSet(variable_tcellSpecific$`Probe ID`, "Variable CpGs in T-cells only, Ecker 2017")
trainTest_cpgSet(variable_monNeutSpecific$`Probe ID`, "Variable CpGs in monocytes and neutrophils only, Ecker 2017")
trainTest_cpgSet(cvd_gwas_cpgs_byPos$cpg, "CpGs +/- 1kb from GWAS catalog CVD SNPs")
trainTest_cpgSet(cvd_gwas_cpgs_byGene$cpg, 
                 "CpGs annotated to genes to which GWAS catalog CVD SNPs are annotated")
```

```{r gene-set-activations_old, eval=F}
msigdb_file <- file("../data/misc/gsea/c2.cp.v6.0.symbols.gmt")  # MSigDB file from http://software.broadinstitute.org/gsea/msigdb/collections.jsp#C2
msigdb <- strsplit(readLines(msigdb_file), split="\t")  # File is tab-separated with gene lists immediately following their names and URLs
names(msigdb) <- purrr::map(msigdb, 1)  # First element of each msig vector is name
msigdb <- purrr::map(msigdb, function(sig) sig[-c(1,2)])  # No need for name or URL

library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
annot <- data.frame(getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19), stringsAsFactors=F)
genes_to_cpgs_df <- annot %>%
  dplyr::rename(gene=UCSC_RefGene_Name, cpg=Name) %>%
  select(gene, cpg) %>%
  separate_rows(gene, sep=";") %>%
  distinct() %>% 
  filter(!is.na(gene), gene!="") %>%
  nest(-gene) %>%
  mutate(cpgs=purrr::map(data, function(d) unique(d$cpg))) %>%
  select(-data)
genes_to_cpgs <- setNames(genes_to_cpgs_df$cpgs, genes_to_cpgs_df$gene)  # List of associated CpGs on 450k array for each gene

sig_to_cpgs <- purrr::map(msigdb, function(sig) unique(unlist(genes_to_cpgs[sig])))

library(flashpcaR)

pca_from_cpgSet <- function(cpgs) {
  cpgs_trimmed <- cpgs[cpgs %in% rownames(betas)]
  pcaMat <- t(betas[cpgs_trimmed,])
  pca.fit <- flashpca(pcaMat, stand="sd", ndim=2, do_loadings=T)
  pc1_loadings <- pca.fit$loadings[,1]
  setNames(pc1_loadings, cpgs_trimmed)
}

geneSetLoadings <- lapply(sig_to_cpgs, pca_from_cpgSet)

t_betas_scaled <- scale(t(betas))
geneSetActivations <- lapply(geneSetLoadings, function(loading) t_betas_scaled[,names(loading)] %*% loading)
geneSetActivationsMat <- do.call(cbind, geneSetActivations)
colnames(geneSetActivationsMat) <- names(geneSetActivations)
```

```{r gene-set-mrs_old, eval=F}
trainset <- which(nonMethData$study=="whi")
testset <- which(nonMethData$study=="fhs")

mod <- "~age+smk_now+CD4T+NK+Bcell+Mono+Gran+PC1_combat+PC2_combat"
covars_frame <- model.frame(mod, nonMethData, na.action=na.pass)  # To allow NAs to pass through
covars_mat <- model.matrix(as.formula(mod), covars_frame)[,-1]  # Converts factors to numeric
stopifnot(all(rownames(geneSetActivationsMat)==nonMethData$sampleKey))
design_mat <- cbind(covars_mat, geneSetActivationsMat)
cvd_surv <- Surv(time=nonMethData$time, event=nonMethData$event)
mrs.fit <- glmnet(design_mat[trainset,], cvd_surv[trainset], family="cox", alpha=0.5,  # Train MRS model
                  penalty.factor=ifelse(colnames(design_mat) %in% names(sig_to_cpgs), 1, 0))
coefs <- mrs.fit$beta[,ncol(mrs.fit$beta)]  # Extract coefficients
coefs_meth <- coefs[coefs!=0 & (names(coefs) %in% names(sig_to_cpgs))]  # Methylation coefficients only
mrs_calc <- as.vector(design_mat[,names(coefs_meth)] %*% coefs_meth)  # Calculate the MRS for all samples
mrs.test <- coxph(cvd_surv~mrs, data=cbind(cvd_surv=cvd_surv, mrs=mrs_calc,  # Test the predictivity of the MRS using a basic Cox model
                                           nonMethData), subset=testset)
hr_per_sd <- exp(sd(mrs_calc[testset])*summary(mrs.test)$coef[,"coef"])
print(cbind(HR_per_SD=hr_per_sd, p=summary(mrs.test)$coef[,"Pr(>|z|)"]))
```



```{r ewas-mrs-out, dependson=-1, eval=F}
ewasResTbl <- map_dfr(ewasMrsRes, function(res) data.frame(res$ewas)) %>%
  mutate(numCpGsUsed=cpgNum, p=format(p, scientific=T))
ewasEnetResTbl <- map_dfr(ewasMrsRes, function(res) data.frame(matrix(res$ewasEnet,1,2))) %>%
  setNames(c("HR_per_SD","p")) %>%
  mutate(numCpGsUsed=cpgNum, p=format(p, scientific=T))

print("EWAS weighted sum approach:")
kable(ewasResTbl)
print("Elastic net regression on EWAS CpGs:")
kable(ewasEnetResTbl)
```








## Basic model -- train in WHI, test in FHS

```{r basic-model2, dependson="misc", eval=F}
print("Beta-values")
trainTestMRS(basic_model, nonMethData, betas,
             trainset=which(nonMethData$study=="whi"),
             testset=which(nonMethData$study=="fhs"))$res

Mvals <- logit2(betas)
print("M-values")
trainTestMRS(basic_model, nonMethData, Mvals,
             trainset=which(nonMethData$study=="whi"),
             testset=which(nonMethData$study=="fhs"))$res
rm(Mvals)

print("Test only in males")
trainTestMRS(basic_model, nonMethData, betas,
             trainset=which(nonMethData$study=="whi"),
             testset=which(nonMethData$study=="fhs" & nonMethData$sex=="M"))$res

print("Test only in females")
trainTestMRS(basic_model, nonMethData, betas,
             trainset=which(nonMethData$study=="whi"),
             testset=which(nonMethData$study=="fhs" & nonMethData$sex=="F"))$res

print("Train in FHS, test in WHI")
trainTestMRS(basic_model, nonMethData, betas,
             trainset=which(nonMethData$study=="fhs"),
             testset=which(nonMethData$study=="whi"))$res
```

```{r basic-model-combatWO, eval=F}
betas_combatWO <- readRDS("../int/betas.qc.norm.filt.combat_eventAdj.rds")
print("With outcome-adjusted ComBat")
trainTestMRS(basic_model, nonMethData, betas_combatWO,
             trainset=which(nonMethData$study=="whi"),
             testset=which(nonMethData$study=="fhs"))$res
rm(betas_combatWO)
```


```{r variance-thresholds-out, cache=F, eval=F}
kable(varThreshTbl)

ggplot(data=mutate(varThreshTbl, negLogP=-log(p)), 
       aes(x=varThreshold, y=negLogP)) +
  geom_point() + 
  geom_line()
```

## Variance thresholds after ComBat

```{r VTC, eval=F}
library(flashpcaR)

betas_C <- readRDS("../int/betas.qc.norm.filt.combat.rds")
betas_C <- betas_C[,colnames(betas)]
beta_variances_C <- apply(betas_C[,nonMethData$study=="whi"], 1, var)

print("25 and 75 %iles of variance threshold with basic ComBat")
varThresh_C <- quantile(beta_variances_C, probs=c(0.25,0.75))
varThreshRes_C <- lapply(varThresh_C, function(thresh) {
  trainTestMRS(basic_model, nonMethData, betas_C[beta_variances_C>thresh,],
               which(nonMethData$study=="whi"),
               which(nonMethData$study=="fhs"))
})
varThreshTbl_C <- map_dfr(varThreshRes_C, function(res) data.frame(res$res)) %>%
  mutate(varThreshold=varThresh_C)

kable(varThreshTbl_C)
rm(betas_C)

betas_CE <- readRDS("../int/betas.qc.norm.filt.combat_eventAdj.rds")
betas_CE <- betas_CE[,colnames(betas)]
beta_variances_CE <- apply(betas_CE[,nonMethData$study=="whi"], 1, var)

print("25 and 75 %iles of variance threshold with outcome-adjusted ComBat")
varThresh_CE <- quantile(beta_variances_CE, probs=c(0.25,0.75))
varThreshRes_CE <- lapply(varThresh_CE, function(thresh) {
  trainTestMRS(basic_model, nonMethData, betas_CE[beta_variances_CE>thresh,],
               which(nonMethData$study=="whi"),
               which(nonMethData$study=="fhs"))
})
varThreshTbl_CE <- map_dfr(varThreshRes_CE, function(res) data.frame(res$res)) %>%
  mutate(varThreshold=varThresh_CE)

kable(varThreshTbl_CE)
rm(betas_CE)
```


## Within-study testing and training
```{r within-study, eval=F}
# Define train/test split
print("FHS only with variance threshold of 75th percentile")
set.seed(1)
nmd_fhs <- nonMethData[nonMethData$study=="fhs",]
trainset <- createDataPartition(factor(nmd_fhs$event), p=0.6)[[1]]  # Set up train/test partition
testset <- setdiff(1:nrow(nmd_fhs), trainset)
kable(trainTestMRS(basic_model, nmd_fhs, 
                   betas[beta_variances>quantile(beta_variances, 0.75),nonMethData$study=="fhs"],
                   trainset, testset)$res)

print("FHS only with variance threshold of 75th percentile")
set.seed(1)
nmd_whi <- nonMethData[nonMethData$study=="whi",]
trainset <- createDataPartition(factor(nmd_whi$event), p=0.6)[[1]]  # Set up train/test partition
testset <- setdiff(1:nrow(nmd_whi), trainset)
kable(trainTestMRS(basic_model, nmd_whi, 
                   betas[beta_variances>quantile(beta_variances, 0.75),nonMethData$study=="whi"],
                   trainset, testset)$res)
```

## What about random sets of 500 CpGs for comparison?
```{r random-cpg-sets, eval=F}
set.seed(1)
randomSets <- lapply(1:5, function(iter) 
  trainTestMRS(basic_model, nonMethData, Mvals[sample(1:nrow(Mvals), 500),], trainset, testset))
randomSetsRes <- map_dfr(randomSets, function(set) data.frame(set$res))
```

```{r random-cpg-sets-out, dependson=-1, eval=F}
kable(randomSetsRes)
```



## Male/female differences
```{r male-female, eval=F}
maleTrainSet <- trainset[nonMethData$sex[trainset]=="M"]
femaleTrainSet <- trainset[nonMethData$sex[trainset]=="F"] 
maleTestSet <- testset[nonMethData$sex[testset]=="M"]
femaleTestSet <- testset[nonMethData$sex[testset]=="F"]
print(paste0("Train on males only (n = ", length(maleTrainSet), "), then test on..."))

print(paste0("Males (n = ", length(maleTestSet), "):"))
res <- trainTestMRS(basic_model, nonMethData, Mvals[Mval_variances>0.4,], maleTrainSet, maleTestSet)
print(res$res)
print(paste0("Females (n = ", length(femaleTestSet), "):"))
res <- trainTestMRS(basic_model, nonMethData, Mvals[Mval_variances>0.4,], maleTrainSet, femaleTestSet)
print(res$res)

print(paste0("Train on females only (n = ", length(femaleTrainSet), "), then test on..."))
print(paste0("Males (n = ", length(maleTestSet), "):"))
res <- trainTestMRS(basic_model, nonMethData, Mvals[Mval_variances>0.4,], femaleTrainSet, maleTestSet)
print(res$res)
print(paste0("Females (n = ", length(femaleTestSet), "):"))
res <- trainTestMRS(basic_model, nonMethData, Mvals[Mval_variances>0.4,], femaleTrainSet, femaleTestSet)
print(res$res)
```

## Stability of the MRS in duplicate samples

```{r mrs-stability, eval=F}
print("ICC of the MRS (trained on entire dataset):")
res <- trainTestMRS(basic_model, nonMethData, Mvals[Mval_variances>0.4,],
                    trainset=seq(1,nrow(nonMethData)), testset=seq(1,nrow(nonMethData)))
mrsValues <- t(Mvals_full[names(res$components),]) %*% res$components
library(ICC)
metaData <- readRDS("../int/metaData.rds")
iccData <- data.frame(shareid=factor(metaData$shareid[match(colnames(Mvals_full), metaData$sampleKey)]),
                      mrs=mrsValues)
iccRes <- ICCest(x=shareid, y=mrs, data=iccData)
print(iccRes$ICC)
```

--->