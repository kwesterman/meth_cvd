---
title: MRS Model Experimentation
output:
pdf_document:
latex_engine: pdflatex
---

```{r prereqs, include=F, cache=F}
library(knitr)
opts_chunk$set(echo=F, cache.lazy=F, cache.path="../cache/mrs_models/",
               fig.keep="high", fig.path="../output/figures/")
suppressMessages(silent <- lapply(
  c("tidyverse","survival","glmnet","minfi","caret","doParallel",
    "itertools","randomForest","pROC"), library, character.only=T))
options(digits=3)
```

```{r load-data}
# Load methylation data
betas_whi <- readRDS("../int/betas.qc.norm.filt_whi.rds")
betas_fhs <- readRDS("../int/betas.qc.norm.filt_fhs.rds")
betas_lbc <- readRDS("../int/betas.qc.norm.filt_lbc.rds")

# Load metadata
metaData <- readRDS("../int/metaData.rds")

# Load estimated cell counts
est_cell_counts_whi <- readRDS("../int/estCellCounts_whi.rds")
est_cell_counts_fhs <- readRDS("../int/estCellCounts_fhs.rds")
est_cell_counts_lbc <- readRDS("../int/estCellCounts_lbc.rds")

# Load CPACOR principal component adjustment factors
load("../int/CPACOR_whi.RData")
CP_PCs_whi <- CP_PCs
load("../int/CPACOR_fhs.RData")
CP_PCs_fhs <- CP_PCs
load("../int/CPACOR_lbc.RData")
CP_PCs_lbc <- CP_PCs

# Load PCA results
load("../int/PCA.fit_whi.RData")
PCs_whi <- PCs
load("../int/PCA.fit_fhs.RData")
PCs_fhs <- PCs
load("../int/PCA.fit_lbc.RData")
PCs_lbc <- PCs

# Load Illumina 450k annotation
library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
anno_450k <- data.frame(
  getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19), 
  stringsAsFactors=F)
```

```{r clean-data, warning=F}
est_cell_counts <- bind_rows(est_cell_counts_whi, est_cell_counts_fhs, 
                             est_cell_counts_lbc)
CP_PCs <- bind_rows(CP_PCs_whi, CP_PCs_fhs, CP_PCs_lbc)
PCs <- bind_rows(PCs_whi, PCs_fhs, PCs_lbc)

### Create master covariate/event data frame
non_meth_data <- Reduce(function(x,y) inner_join(x, y, by="sampleKey"), 
                        list(metaData, est_cell_counts, CP_PCs, PCs)) %>%
  filter(is.na(wave) | wave == 1) %>%
  distinct(subjID, .keep_all=T)  # Better way of deciding which biological replicates to keep?
# non_meth_data <- replace_na(non_meth_data, 
#                           list(bmi=median(non_meth_data$bmi, na.rm=T),
#                                smk_now=0, smk_py=0, ht_med=0, lipid_med=0, dm_med=0)) %>%
#   mutate(diabetes=dm_med | glu>125) %>%
#   mutate_at(c("chol","ldl","hdl","tg","sbp","glu","hscrp"), log10)
### THINK MORE ABOUT ABOVE WRANGLING ###

nmd_whi <- filter(non_meth_data, study == "whi")
nmd_fhs <- filter(non_meth_data, study == "fhs")
nmd_lbc <- filter(non_meth_data, study %in% c("lbc21","lbc36"))

betas_whi <- betas_whi[, nmd_whi]
betas_fhs <- betas_fhs[, nmd_fhs]
betas_lbc <- betas_lbc[, nmd_lbc]
stopifnot(all(colnames(betas_whi) == nmd_whi$sampleKey),
          all(colnames(betas_fhs) == nmd_fhs$sampleKey),
          all(colnames(betas_lbc) == nmd_lbc$sampleKey))  # Ensure identical number and order of samples for methylation and covariate data
```

```{r train-test-funcs}
construct_design_mat <- function(cpgs, betas, covars, meta, trainset) {
  covar_formula <- as.formula(paste("~", paste(covars, collapse="+")))
  covars_frame <- model.frame(covar_formula, meta, na.action=na.pass)  # To allow NAs to pass through
  covars_mat <- model.matrix(covar_formula, covars_frame)[,-1]  # Converts factors to numeric
  cbind(covars_mat, t(betas[cpgs,]))
}

test_mrs <- function(meta, mrs) {
  meta$mrs <- scale(mrs)
  meta$cvd_surv <- Surv(time=meta$time, event=meta$event)  # Outcome
  mrs_test <- coxph(cvd_surv~mrs, data=meta) # Test the MRS using a Cox model
  mrs_res <- summary(mrs_test)$coef["mrs",c("exp(coef)","z")]
  tibble(HR_per_SD=mrs_res["exp(coef)"], p=2 * pnorm(-abs(mrs_res["z"])))
}

test_grs <- function(grs_df) {
  # grs_df input should have both event data and a column names "grs"
  grs_df$grs <- scale(grs_df$grs)
  grs_test <- glm(event ~ grs, data=grs_df, family="binomial")
  grs_res <- summary(grs_test)$coef["grs",c("Estimate","z value")]
  tibble(OR_per_SD=exp(grs_res["Estimate"]), p=2 * pnorm(-abs(grs_res["z value"])))
}

format_p_vals <- function(tbl) {
  if(any(colnames(tbl) == "p")) {
    tbl <- mutate(tbl, p=case_when(p > 0.1 ~ round(p, 2),
                                   p > 0.001 ~ signif(p, 2),
                                   TRUE ~ format(p, digits=2, scientific=T)))
  }
  tbl
}

# trainTestMRS <- function(mod, meta, meth, trainset, testset, alpha=0.5, nfolds=5, lmr=0.1, lt="lambda.min", parallel=F) {
#   mrs_fit <- train_mrs(mod, meta, meth, trainset, alpha=alpha, nfolds=nfolds, lmr=lmr, lambda.type=lt, parallel=parallel)
#   mrs_values <- calc_mrs(mrs_fit$cpg_coefs, meth)
#   mrs_test <- tryCatch(test_mrs(meta, mrs_values, testset), error=function(e) matrix(NA, 1, 2))
#   list(fit=mrs_fit, components=mrs_fit$cpg_coefs, values=mrs_values, res=mrs_test)
# }
```

```{r glmnet-funcs}
train_glmnet <- function(X, y, alpha=0.5, nfolds=5, 
                         parallel=F, s="lambda.min") {
  mrs_fit_cv <- cv.glmnet(X, y, family="cox", alpha=alpha,  # Train MRS model
                          penalty.factor=ifelse(grepl("^cg", colnames(X)), 1, 0),
                          nfolds=nfolds, parallel=parallel)
  coefs <- coef(mrs_fit_cv, s=s)
  cpg_coefs <- coefs[grepl("^cg", rownames(coefs)),]
  list(fit=mrs_fit_cv,  # Output is a list containing the model fit and the CpG model coefficients
       all_coefs=coefs,
       cpg_coefs=cpg_coefs)
}

calc_mrs_glmnet <- function(coefs, meth) {
  if (length(coefs) == 0 || all(coefs == 0)) {
    message("No non-zero coefficients")
    return(rep(NA, ncol(meth)))
  } else {
    nonzero_coefs <- coefs[coefs!=0]
    usefulCoefs <- nonzero_coefs[names(nonzero_coefs) %in% rownames(meth)]
    as.vector(t(meth[names(usefulCoefs), , drop=F]) %*% usefulCoefs)
  }
}  
```

# MRS model construction and parameter optimization

## Basic first models

Basic MRS modeling -- each model is trained on a single cohort using elastic net regression on the top 50% most variable CpGs.

```{r basic-mrs, cache=1}
variances_whi <- apply(betas_whi, 1, var)
high_var_cpgs_whi <- rownames(betas_whi)[(
  variances_whi > quantile(variances_whi, 0.5))]
covars_whi <- c("dnaPull")
design_mat_whi <- construct_design_mat(high_var_cpgs_whi, betas_whi, 
                                       covars_whi, nmd_whi)
cvd_surv_whi <- Surv(nmd_whi$time, nmd_whi$event)

variances_fhs <- apply(betas_fhs, 1, var)
high_var_cpgs_fhs <- rownames(betas_fhs)[(
  variances_fhs > quantile(variances_fhs, 0.5))]
covars_fhs <- c("center", paste0("cpPC", 1:7))
design_mat_fhs <- construct_design_mat(high_var_cpgs_fhs, betas_fhs, 
                                       covars_fhs, nmd_fhs)
cvd_surv_fhs <- Surv(nmd_fhs$time, nmd_fhs$event)

variances_lbc <- apply(betas_lbc, 1, var)
high_var_cpgs_lbc <- rownames(betas_lbc)[(
  variances_lbc > quantile(variances_lbc, 0.5))]
covars_lbc <- c("cpPC1")
design_mat_lbc <- construct_design_mat(high_var_cpgs_lbc, betas_lbc, 
                                       covars_lbc, nmd_lbc)
cvd_surv_lbc <- Surv(nmd_lbc$time, nmd_lbc$event)

cl <- makePSOCKcluster(3)
registerDoParallel(cl)

mrs_fit_whi <- train_glmnet(design_mat_whi, cvd_surv_whi, 
                            alpha=0.5, nfolds=3, parallel=T)
mrs_fit_fhs <- train_glmnet(design_mat_fhs, cvd_surv_fhs, 
                            alpha=0.5, nfolds=3, parallel=T)
mrs_fit_lbc <- train_glmnet(design_mat_lbc, cvd_surv_lbc, 
                            alpha=0.5, nfolds=3, parallel=T)

stopCluster(cl)
```

```{r test-basic-mrs}
# Test WHI
mrs_fhs <- calc_mrs_glmnet(mrs_fit_whi$cpg_coefs, betas_fhs)
mrs_res_fhs <- test_mrs(nmd_fhs, mrs_fhs)
mrs_lbc <- calc_mrs_glmnet(mrs_fit_whi$cpg_coefs, betas_lbc)
mrs_res_lbc <- test_mrs(nmd_lbc, mrs_lbc)
kable(bind_rows(list(FHS=mrs_res_fhs), .id="testCohort"), 
      caption="Trained in WHI")

# Test FHS
mrs_whi <- calc_mrs_glmnet(mrs_fit_fhs$cpg_coefs, betas_whi)
mrs_res_whi <- test_mrs(nmd_whi, mrs_whi)
mrs_lbc <- calc_mrs_glmnet(mrs_fit_fhs$cpg_coefs, betas_lbc)
mrs_res_lbc <- test_mrs(nmd_lbc, mrs_lbc)
kable(bind_rows(list(WHI=mrs_res_whi), .id="testCohort"), 
      caption="Trained in FHS")

# # Test LBC
# mrs_whi <- calc_mrs_glmnet(mrs_fit_lbc$cpg_coefs, betas_whi)
# mrs_res_whi <- test_mrs(nmd_whi, mrs_whi)
# mrs_fhs <- calc_mrs_glmnet(mrs_fit_lbc$cpg_coefs, betas_fhs)
# mrs_res_fhs <- test_mrs(nmd_fhs, mrs_fhs)
# kable(bind_rows(list(WHI=mrs_res_whi, FHS=mrs_res_fhs), .id="testCohort"), 
#       caption="Trained in LBC")
```

## Variance thresholds

Training in WHI, testing in FHS & LBC.

```{r variance-thresholds, cache=1, message=F}
cl <- makePSOCKcluster(3)
registerDoParallel(cl)

var_thresh_quantiles <- c(0, 0.25, 0.5, 0.75, 0.9)
var_fits_whi_list <- lapply(var_thresh_quantiles, function(vtq) {
  cpg_set <- rownames(betas_whi)[variances_whi > quantile(variances_whi, vtq)]
  design_mat <- construct_design_mat(cpg_set, betas_whi, "dnaPull", nmd_whi)
  train_glmnet(design_mat, cvd_surv_whi, alpha=0.5, nfolds=3, parallel=T)
})

stopCluster(cl)
```

```{r test-variance-thresholds, fig.asp=1.5}
var_res_whi_list <- lapply(var_fits_whi_list, function(fit) {
  mrs_fhs <- test_mrs(nmd_fhs, calc_mrs_glmnet(fit$cpg_coefs, betas_fhs))
  mrs_lbc <- test_mrs(nmd_lbc, calc_mrs_glmnet(fit$cpg_coefs, betas_lbc))
  bind_rows(list(FHS=mrs_fhs, LBC=mrs_lbc), .id="testCohort")
})

var_res_plot_data <- bind_rows(var_res_whi_list, .id="variance_threshold") %>%
  mutate(variance_threshold=var_thresh_quantiles[(
    as.numeric(variance_threshold))],
         negLogP=-log10(p)) %>%
  dplyr::select(testCohort, variance_threshold, HR_per_SD, 
                negLogP, testCohort) %>%
  gather(key=metric, value=value, HR_per_SD, negLogP)

ggplot(var_res_plot_data, aes(x=variance_threshold, y=value, 
                              color=testCohort, group=testCohort)) + 
  geom_point() +
  geom_line() +
  facet_wrap(~metric, nrow=2, scales="free")
```

## Manipulation of alpha

Does the elastic net alpha parameter have any notable effect on the results? Try it out using 75th quantile variance threshold.

```{r alphas, cache=1, message=F}
cl <- makePSOCKcluster(3)
registerDoParallel(cl)

alphas <- c(0.25, 0.5, 0.75)
alpha_fits_whi_list <- lapply(alphas, function(a) {
  cpg_set <- rownames(betas_whi)[variances_whi>quantile(variances_whi, 0.75)]
  design_mat <- construct_design_mat(cpg_set, betas_whi, "dnaPull", nmd_whi)
  train_glmnet(design_mat, cvd_surv_whi, alpha=a, nfolds=3, parallel=T)
})

stopCluster(cl)
```

```{r test-alphas, warning=F}
alpha_res_whi_list <- lapply(alpha_fits_whi_list, function(fit) {
  mrs_fhs <- test_mrs(nmd_fhs, calc_mrs_glmnet(fit$cpg_coefs, betas_fhs))
  mrs_lbc <- test_mrs(nmd_lbc, calc_mrs_glmnet(fit$cpg_coefs, betas_lbc))
  bind_rows(list(FHS=mrs_fhs, LBC=mrs_lbc), .id="testCohort")
})

alpha_res_plot_data <- bind_rows(alpha_res_whi_list, .id="alpha") %>%
  mutate(alpha=alphas[as.numeric(alpha)],
         negLogP=-log10(p)) %>%
  dplyr::select(testCohort, alpha, HR_per_SD, negLogP, testCohort) %>%
  gather(key=metric, value=value, HR_per_SD, negLogP)

ggplot(alpha_res_plot_data, aes(x=alpha, y=value, 
                                color=testCohort, group=testCohort)) + 
  geom_point() +
  geom_line() +
  facet_wrap(~metric, nrow=2, scales="free")
```

## Covariate exploration

When training in WHI, does adjustment for age or cell counts impact the eventual generalization to other cohorts?

```{r mrs-covariate-exploration, cache=1}
design_mat_whi_age <- construct_design_mat(high_var_cpgs_whi, betas_whi, 
                                           c("dnaPull","age"), nmd_whi)
design_mat_whi_cell_counts <- construct_design_mat(
  high_var_cpgs_whi, betas_whi, 
  c("dnaPull","CD4T","CD8T","NK","Bcell","Mono","Gran"), nmd_whi)
cvd_surv_whi <- Surv(nmd_whi$time, nmd_whi$event)

cl <- makePSOCKcluster(3)
registerDoParallel(cl)

mrs_fit_whi_age <- train_glmnet(design_mat_whi_age, cvd_surv_whi, 
                                alpha=0.5, nfolds=3, parallel=T)
mrs_fit_whi_cell_counts <- train_glmnet(design_mat_whi_cell_counts, 
                                        cvd_surv_whi, alpha=0.5, nfolds=3, 
                                        parallel=T)

stopCluster(cl)
```

```{r test-mrs-covariate-exploration}
mrs_res_fhs_age_adj <- test_mrs(
  nmd_fhs, calc_mrs_glmnet(mrs_fit_whi_age$cpg_coefs, betas_fhs))
mrs_res_lbc_age_adj <- test_mrs(
  nmd_lbc, calc_mrs_glmnet(mrs_fit_whi_age$cpg_coefs, betas_lbc))
kable(bind_rows(list(FHS=mrs_res_fhs_age_adj, LBC=mrs_res_lbc_age_adj), 
                .id="testCohort"), 
      caption="Trained in WHI with age adjustment")

mrs_res_fhs_cell_count_adj <- test_mrs(
  nmd_fhs, calc_mrs_glmnet(mrs_fit_whi_cell_counts$cpg_coefs, betas_fhs))
mrs_res_lbc_cell_count_adj <- test_mrs(
  nmd_lbc, calc_mrs_glmnet(mrs_fit_whi_cell_counts$cpg_coefs, betas_lbc))
kable(bind_rows(list(FHS=mrs_res_fhs_cell_count_adj, 
                     LBC=mrs_res_lbc_cell_count_adj), 
                .id="testCohort"), 
      caption="Trained in WHI with cell count adjustment")
```

```{r ewas-mrs, dependson=c("ewas-cpacorOnly","ewas-fullAdjustment"), eval=F}
ewas_res_df <- ewas_res_df_cpacorOnly ## FOR NOW, ADDRESS THIS LATER?

cpg_num <- c(25, 50, 100, 250, 500, 1000)
ewas_mrs_weighted_sum <- lapply(cpg_num, function(num) {
  mrs_coefs <- setNames(ewas_res_df[seq(1, num), "coef"], 
                        ewas_res_df[seq(1, num), "CpG"])
  mrs_calc <- calc_mrs(mrs_coefs, betas)
  mrs_test <- test_mrs(non_meth_data, mrs_calc, fhsSet)
  mrs_test
})
ewas_mrs_weighted_sum_df <- do.call(rbind, ewas_mrs_weighted_sum) %>%
  mutate(numberOfCpGsUsed=cpg_num)

cpacor_adj_model <- paste0("~", paste0("cpPC", 1:10, "_indiv", collapse="+"))
ewas_mrs_enet_list <- lapply(cpg_num, function(num) {
  top_cpgs <- ewas_res_df$CpG[seq(1,num)]
  trainTestMRS(cpacor_adj_model, non_meth_data, betas[top_cpgs, ], 
               whiSet, fhsSet)
})
ewas_mrs_enet_df <- do.call(rbind, purrr::map(ewas_mrs_enet_list, "res")) %>%
  data.frame(stringsAsFactors=F, check.names=F) %>%
  mutate(numberOfCpGsUsed=cpg_num)
```

```{r cvd-snp-mrs, message=F, eval=F}
cvd_gwas_associations <- read_tsv(
  "../data/literature/gwas-association-downloaded_2017-09-18-cardiovascular disease.tsv")
cvd_gwas_cpgs_by_pos <- cvd_gwas_associations %>%
  mutate(chr=paste0("chr", CHR_ID),
         snp_pos=CHR_POS) %>%
  select(chr, snp_pos) %>%
  inner_join(select(anno_450k, Name, chr, pos), by="chr") %>%
  mutate(snp_pos=as.numeric(snp_pos)) %>%
  filter(pos >= snp_pos-1000, pos <= snp_pos+1000) %>%
  dplyr::rename(cpg=Name) %>%
  distinct(cpg)
cvd_cpgs <- cvd_gwas_cpgs_by_pos$cpg
cvd_model <- trainTestMRS(cpacor_adj_model, non_meth_data, 
                         betas[rownames(betas) %in% cvd_cpgs, ], whiSet, fhsSet)
cvd_res <- cvd_model$res
```

```{r display-cpg-set-comparison, cache=F, dependson=c("ewas-mrs","variance-thresholds","cvd-snp-mrs"), out.width="80%", eval=F}

kable(mutate(ewas_mrs_weighted_sum_df, p=as.character(format(p, digits=3))), 
      caption="Using direct weights from EWAS")
# ggplot(ewas_mrs_weighted_sum_df, aes(x=numberOfCpGsUsed, y=HR_per_SD)) + 
#   geom_point() + 
#   geom_line() +
#   ylab("Estimated HR per SD") +
#   ggtitle("Using direct weights from EWAS")

kable(mutate(ewas_mrs_enet_df, p=as.character(format(p, digits=3))), 
      caption="Using top CpGs from EWAS as input to elastic net")
# ggplot(ewas_mrs_enet_df, aes(x=numberOfCpGsUsed, y=HR_per_SD)) + 
#   geom_point() + 
#   geom_line() +
#   ylab("Estimated HR per SD") +
#   ggtitle("Using top CpGs from EWAS as input to elastic net")

kable(mutate(cvd_res, p=as.character(format(p, digits=3))), 
      caption="Using ~1k CpGs near CVD GWAS loci as input to elastic net")

kable(mutate(varResDF, p=as.character(format(p, digits=3))), 
      caption="Using a naive CpG variance threshold before running elastic net")
# ggplot(varResDF, aes(x=varThreshold_percent, y=HR_per_SD)) + 
#   geom_point() + 
#   geom_line() +
#   xlab("Variance threshold (quantile)") +
#   ylab("Estimated HR per SD") +
#   ggtitle("Using a naive CpG variance threshold before running elastic net")
```

## Final multi-cohort methylation model

```{r dual-train, cache=1, include=F}
shared_cpgs_whiLbc <- intersect(rownames(betas_whi), rownames(betas_lbc))
design_mat_whiLbc <- construct_design_mat(
  intersect(high_var_cpgs_whi, high_var_cpgs_lbc),
  cbind(betas_whi[shared_cpgs_whiLbc,], betas_lbc[shared_cpgs_whiLbc, ]),
  c("study"), bind_rows(nmd_whi, nmd_lbc))
cvd_surv_whiLbc <- Surv(rbind(cvd_surv_whi, cvd_surv_lbc))

cl <- makePSOCKcluster(3)
registerDoParallel(cl)
mrs_fit_whiLbc <- train_glmnet(design_mat_whiLbc, cvd_surv_whiLbc, 
                               alpha=0.5, nfolds=3, parallel=T)
stopCluster(cl)
```

```{r test-dual-train, include=F}
mrs_fhs <- calc_mrs_glmnet(mrs_fit_whiLbc$cpg_coefs, betas_fhs)
mrs_res_fhs <- test_mrs(nmd_fhs, mrs_fhs)
kable(mrs_res_fhs, caption="Trained in WHI & LBC")
```

Trained in WHI & FHS together.

```{r train-test-split}
nmd_whiFhs <- bind_rows(nmd_whi, nmd_fhs) %>% 
  mutate(batch = ifelse(study == "whi", "whi", center))

set.seed(1)
trainset <- createDataPartition(factor(nmd_whiFhs$event), p=0.7)[[1]]
testset <- seq(1, nrow(nmd_whiFhs))[-trainset]
```

```{r train-mcmm, cache=1}
shared_cpgs_whiFhs <- intersect(rownames(betas_whi), rownames(betas_fhs))
design_mat_whiFhs <- construct_design_mat(
  intersect(high_var_cpgs_whi, high_var_cpgs_fhs),
  cbind(betas_whi[shared_cpgs_whiFhs,], betas_fhs[shared_cpgs_whiFhs,]),
  c("batch"), nmd_whiFhs)
cvd_surv_whiFhs <- Surv(rbind(cvd_surv_whi, cvd_surv_fhs))

cl <- makePSOCKcluster(3)
registerDoParallel(cl)
mrs_fit_whiFhs <- train_glmnet(design_mat_whiFhs[trainset, ], 
                               cvd_surv_whiFhs[trainset], 
                               alpha=0.5, nfolds=3, parallel=T)
stopCluster(cl)
```

```{r test-mcmm}
relevant_betas <- t(design_mat_whiFhs[,grepl("^cg", colnames(design_mat_whiFhs))])
mrs_whiFhs <- calc_mrs_glmnet(mrs_fit_whiFhs$cpg_coefs, relevant_betas[,testset])
mrs_res_whiFhs <- test_mrs(nmd_whiFhs[testset,], mrs_whiFhs)
kable(mrs_res_whiFhs, caption="Performance in 30% held-out test set")
```

```{r train-mcmm-full, cache=1}
cl <- makePSOCKcluster(3)
registerDoParallel(cl)
mrs_fit_whiFhs_full <- train_glmnet(design_mat_whiFhs, cvd_surv_whiFhs, 
                                    alpha=0.5, nfolds=3, parallel=T)
stopCluster(cl)
```

```{r test-mcmm-full}
mrs_lbc <- calc_mrs_glmnet(mrs_fit_whiFhs_full$cpg_coefs, betas_lbc)
mrs_res_lbc <- test_mrs(nmd_lbc, mrs_lbc)
mrs_lbc21 <- calc_mrs_glmnet(mrs_fit_whiFhs_full$cpg_coefs, 
                             betas_lbc[, nmd_lbc$study == "lbc21"])
mrs_res_lbc21 <- test_mrs(filter(nmd_lbc, study == "lbc21"), mrs_lbc21)
mrs_lbc36 <- calc_mrs_glmnet(mrs_fit_whiFhs_full$cpg_coefs, 
                             betas_lbc[, nmd_lbc$study == "lbc36"])
mrs_res_lbc36 <- test_mrs(filter(nmd_lbc, study == "lbc36"), mrs_lbc36)
kable(bind_rows(list(`LBC (full)`=mrs_res_lbc, LBC21=mrs_res_lbc21, 
                     LBC36=mrs_res_lbc36), .id="Test cohort"),
      caption="Testing full model in LBC")
```

```{r evaluation, cache=F, eval=F}
source("helpers.R")

run_mrs_lr <- function(dat, mrs_values) {
  dat$mrs <- scale(mrs_values)
  dat <- dat %>%
    mutate(diabetes=dm_med|glu>125) %>%
    replace_na(list(diabetes=F))
  dat$frs <- calc_FRS(dat)
  testset <- which(dat$study == "fhs" & !is.na(dat$frs))
  mrs_only <- glm(event~mrs, data=dat, subset=testset)
  frs_only <- glm(event~frs, data=dat, subset=testset)
  combined <- glm(event~mrs+frs, data=dat, subset=testset)
  list(mrs=mrs_only, frs=frs_only, combined=combined, testset=testset)
}

lr_res <- run_mrs_lr(non_meth_data, varRes.list[[3]]$values)
mrs_ROC <- roc(non_meth_data$event[lr_res$testset], predict(lr_res$mrs))
plot(mrs_ROC, col="red")
frs_ROC <- roc(non_meth_data$event[lr_res$testset], predict(lr_res$frs))
plot(frs_ROC, col="blue", add=T)
combined_ROC <- roc(non_meth_data$event[lr_res$testset], predict(lr_res$combined))
plot(combined_ROC, col="green", add=T)
legend("bottomright", 
       legend=paste0(c("MRS: auc=", "FRS: auc=", "MRS+FRS: auc="), 
                     round(as.numeric(c(mrs_ROC$auc, frs_ROC$auc, 
                                        combined_ROC$auc)), 2)), 
       col=c("blue", "red", "green"), lty=1, lwd=3, cex=1.3)
```

<!--For appropriate comparison to the Framingham Risk Score, the evaluation here is based on a binary classification of whether an incident event did or did not occur. The basic MRS shows a reasonable c-statistic (ROC area under the curve) of 0.66, comparable to that of my implementation of the FRS algorithm. There seems to be a bit of synergy between the two risk scores, as performance increases slightly when using them together. One important caveat is that the FRS is generally estimated to show a c-statistic closer to 0.75, so it is possible that FHS Offspring is not an optimal test cohort (because cholesterol is not predictive of CVD risk in this population?) or that there is some error in my coding of the FRS.-->



<!--Though the MRS above is trained in a female-only cohort, there is no evidence here of any bias of the MRS towards predicting events in females. Based on previous results, there was also reason to believe that prior CVD could be an important confounder -- this could manifest as a much better performance of the classifier in those who experienced prior CVD events, but there doesn't seem to be any such effect here.-->






<!--
# Exploration of model variants

To facilitate exploration of binary classifiers, testing from this point on uses logistic regression/odds ratios to evaluate MRS performance rather than Cox regression/hazard ratios. The CpG set used is still the 75th quantile variance threshold set.

```{r binary-funcs, eval=F}
train_mrs_binary <- function(mod, meta, meth, trainset, 
alpha=0.5, nfolds=5, lmr=0.1, lambda.type="lambda.min", parallel=F) {
covars_frame <- model.frame(as.formula(mod), meta, na.action=na.pass)  # To allow NAs to pass through
covars_mat <- model.matrix(as.formula(mod), covars_frame)[,-1]  # Converts factors to numeric
design_mat <- cbind(covars_mat, t(meth))
eventVec <- factor(meta$event)
mrs_fit_cv <- cv.glmnet(design_mat[trainset,], eventVec[trainset], family="binomial", alpha=alpha,
penalty.factor=ifelse(grepl("^cg", colnames(design_mat)), 1, 0), 
nfolds=nfolds, lambda.min.ratio=lmr, parallel=parallel)
coefs <- coef(mrs_fit_cv, s=lambda.type)
cpg_coefs <- coefs[grepl("^cg", rownames(coefs)),]
list(fit=mrs_fit_cv,  # Output is a list containing the model fit and the CpG model coefficients
all_coefs=coefs,
cpg_coefs=cpg_coefs)
}

test_mrs_binary <- function(meta, mrs, testset) {
meta$mrs <- scale(mrs)
mrs_test <- glm(event~mrs, data=meta, family="binomial", subset=testset) # Test the MRS using a Cox model
res <- summary(mrs_test)$coef["mrs",c("Estimate","Pr(>|z|)")]  # Outputs a vector
tibble(OR_per_SD=exp(res["Estimate"]), p=res["Pr(>|z|)"])
}

trainTestMRS_binary <- function(mod, meta, meth, trainset, testset, alpha=0.5, nfolds=5, lmr=0.1, lt="lambda.min", parallel=F) {
mrs_fit <- train_mrs_binary(mod, meta, meth, trainset, 
alpha=alpha, nfolds=nfolds, lmr=lmr, lambda.type=lt, parallel=parallel)
mrs_values <- calc_mrs(mrs_fit$cpg_coefs, meth)
mrs_test <- tryCatch(test_mrs_binary(meta, mrs_values, testset), error=function(e) matrix(NA, 1, 2))
list(fit=mrs_fit, components=mrs_fit$cpg_coefs, values=mrs_values, res=mrs_test)
}
```

```{r binary-test-baseline, eval=F}
binTestOnlyRes <- test_mrs_binary(non_meth_data, varRes.list[[3]]$values, fhsSet)
```

```{r binary-mrs, dependson="binary-funcs", eval=F}
cl <- makePSOCKcluster(4)
registerDoParallel(cl)
binaryModel <- trainTestMRS_binary(cpacor_adj_model, non_meth_data, 
logit2(betas[beta_variances>quantile(beta_variances,0.75),]),
whiSet, fhsSet, parallel=T)
stopCluster(cl)

binaryRes <- binaryModel$res
```

```{r display-binary-tests, dependson=c("binary-test-baseline","binary-mrs"), eval=F}
kable(mutate(binTestOnlyRes, p=as.character(format(p,digits=3))), caption="Test the same 75th quantile MRS from above for binary CVD event outcome")
kable(mutate(binaryRes, p=as.character(format(p,digits=3))), caption="Training and testing using a binary outcome")
```

```{r Mvals, eval=F}
cl <- makePSOCKcluster(4)
registerDoParallel(cl)
mvalModel <- trainTestMRS(cpacor_adj_model, non_meth_data, 
logit2(betas[beta_variances>quantile(beta_variances,0.75),]),
whiSet, fhsSet, parallel=T)
stopCluster(cl)

mvalRes_binTest <- test_mrs_binary(non_meth_data, mvalModel$values, fhsSet)
```

```{r display-Mvals, eval=F}
kable(mutate(mvalRes_binTest, p=as.character(format(p,digits=3))), caption="Using M-values instead of beta values")
```

```{r random-forest, message=F, eval=F}
testTrain_RF <- function(mod, meta, meth, trainset, testset, ntree, ncores, seed=1) {
set.seed(seed)
covars_frame <- model.frame(as.formula(mod), meta, na.action=na.pass)  # To allow NAs to pass through
covars_mat <- model.matrix(as.formula(mod), covars_frame)[,-1]  # Converts factors to numeric
design_mat <- t(meth)
rf.fit <- foreach(nt=rep(ntree/ncores,ncores), .combine=randomForest::combine, .packages="randomForest") %dopar%
randomForest(design_mat[trainset,], factor(meta$event)[trainset], ntree=nt)
rf_mrs <- predict(rf.fit, newdata=design_mat, type="prob")[,"TRUE"]
rf_test <- test_mrs(meta, rf_mrs, testset)
list(res=rf_test, fit=rf.fit, values=rf_mrs)
}

cl <- makePSOCKcluster(8)
registerDoParallel(cl)
rfModel <- testTrain_RF(cpacor_adj_model, non_meth_data, betas[beta_variances>quantile(beta_variances,0.75),], 
whiSet, fhsSet, ntree=80*8, ncores=8)
stopCluster(cl)

rfRes <- rfModel$res
```

```{r display-rf, eval=F}
# Hack for now
rfRes <- test_mrs_binary(non_meth_data, rfModel$values, fhsSet) %>%
mutate(p=as.character(format(p,digits=3)))
kable(rfRes, caption="Random forest model")
```

The first two tables above compare models that are both tested using binary classifiers, but one is trained using a Cox model while the other is trained through a logistic model. As might be expected, a notable increase in performance is achieved by the Cox model, as it is able to take advantage of additional time-to-event information.

Performance of the full training and testing procedure using M-values does not seem to improve performance.

A random forest model trained on the same set of CpGs and a binary event outcome shows a comparably high OR, but the p-value doesn't indicate notable predictive ability -- what is going on here? To investigate, here are the distributions of the probabilities output by the random forest algorithm (used here as the MRS).

```{r rf-mrs-distributions, cache=F, fig.show="hold", out.width="50%", eval=F}
hist(rfModel$values[whiSet], main="RF prob. distribution (training set)")
hist(rfModel$values[fhsSet], main="RF prob. distribution (test set)")
hist(varRes.list[[3]]$values[whiSet], main="Regression-based MRS distribution in training \nset, for comparison ")
```

Clearly, the random forest is overfitting -- it is way too good at classifying incident events in the training set. Likely it is identifying WHI-specific population specific or batch effects, especially since I was not able to adjust for control probe PCs in the random forest model training. So, it may be helpful to combine my two datasets before creating a train-test split in order to mitigate these population-specific patterns.

## Cross-cohort training

Here, the populations were combined and the full dataset was randomly divided into a 70/30 train/test split, while ensuring proportional numbers of incident events in each set.

```{r enet-combined, eval=F}
beta_variances_trainset <- apply(betas[,trainset], 1, var)

cl <- makePSOCKcluster(5)
registerDoParallel(cl)
enetCombined <- trainTestMRS(cpacor_adj_model, non_meth_data, 
betas[beta_variances_trainset>quantile(beta_variances_trainset,0.75),],
trainset, testset, parallel=T)
stopCluster(cl)

enetCombined_binTest <- test_mrs_binary(non_meth_data, enetCombined$values, testset)
```

```{r rf-combined, eval=F}
cl <- makePSOCKcluster(8)
registerDoParallel(cl)
rfModelCombined <- testTrain_RF(cpacor_adj_model, non_meth_data, 
betas[beta_variances_trainset>quantile(beta_variances_trainset,0.75),], 
trainset, testset, ntree=80*8, ncores=8)
stopCluster(cl)

rfResCombined <- rfModelCombined$res
```

```{r display-combined-models, eval=F}
sep_vs_combined_regression <- rbind(binTestOnlyRes, enetCombined_binTest) %>%
mutate(model=c("WHI train, FHS test","Combined 70/30 split"),
p=as.character(format(p,digits=3)))
kable(sep_vs_combined_regression, caption="Elastic net regression")

## For now....
rfCombined_binTest <- test_mrs_binary(non_meth_data, rfModelCombined$values, testset)

sep_vs_combined_rf <- rbind(rfRes, rfCombined_binTest) %>%
mutate(model=c("WHI train, FHS test","Combined 70/30 split"),
p=as.character(format(p,digits=3)))
kable(sep_vs_combined_rf, caption="Random forest")
```

### Evaluation of cross-cohort trained models

```{r evaluate-combined-models, cache=F, out.width="50%", eval=F}
library(pROC)

enetROC <- roc(non_meth_data$event[testset], enetCombined$values[testset])
plot(enetROC, print.auc=T, main="Regression-based MRS")

rfROC <- roc(non_meth_data$event[testset], rfModelCombined$values[testset])
plot(rfROC, print.auc=T, main="Random forest-based MRS")
```

### Is this model fitting only dataset-specific patterns?

Try to evaluate this by fitting separate models in WHI and FHS.

```{r dataset-specific, eval=F}
fhsMeta <- non_meth_data[fhsSet,]
set.seed(1)
fhsTrain <- createDataPartition(factor(fhsMeta$event), p=0.7)[[1]]
fhsTest <- seq(1,nrow(fhsMeta))[-fhsTrain]
beta_variances_fhsTrain <- apply(betas[,fhsSet[fhsTrain]], 1, var)
cl <- makePSOCKcluster(5)
registerDoParallel(cl)
dsFHSModel <- trainTestMRS(cpacor_adj_model, fhsMeta, 
betas[beta_variances_fhsTrain>quantile(beta_variances_fhsTrain,0.75),fhsSet], 
fhsTrain, fhsTest, parallel=T)
dsFHSRes <- test_mrs_binary(fhsMeta, dsFHSModel$values, fhsTest)
stopCluster(cl)

whiMeta <- non_meth_data[whiSet,]
set.seed(1)
whiTrain <- createDataPartition(factor(whiMeta$event), p=0.7)[[1]]
whiTest <- seq(1,nrow(whiMeta))[-whiTrain]
beta_variances_whiTrain <- apply(betas[,whiSet[whiTrain]], 1, var)
cl <- makePSOCKcluster(5)
registerDoParallel(cl)
dsWHIModel <- trainTestMRS(cpacor_adj_model, whiMeta, 
betas[beta_variances_whiTrain>quantile(beta_variances_whiTrain,0.75),whiSet], 
whiTrain, whiTest, parallel=T)
dsWHIRes <- test_mrs_binary(whiMeta, dsWHIModel$values, whiTest)
stopCluster(cl)
```

```{r display-dataset-specific, eval=F}
kable(dsFHSRes, caption="Train and test in FHS only")
kable(dsWHIRes, caption="train and test in WHI only")
```

Though ideally there would be a fully independent validation set available, the mediocre within-cohort cross-validation results don't indicate any population-specific effects of a strength that would dominate the above combined regression results.



# Biological significance of the MRS

## Biological covariates

The intent to this point was to determine the "maximum predictive power" of microarray-based methylation data in predicting CVD events. However, known associations of methylation with sex, age, white blood cell proportions, etc. may explain a substantial fraction of this predictive power. 

```{r biological-significance, cache=F, eval=F}
wbcCounts <- dplyr::select(non_meth_data, CD4T, CD8T, Bcell, NK, Mono, Gran)
non_meth_data$wbcPC1 <- prcomp(wbcCounts, scale.=T)$x[,1]
non_meth_data$wbcPC2 <- prcomp(wbcCounts, scale.=T)$x[,2]

singleCovs <- c("sex","age","bmi","wbcPC1","wbcPC2","smk_now","ht_med","lipid_med","dm_med")
covs <- c("none", singleCovs, paste0(singleCovs, collapse="+"))
names(covs) <- c(covs[1:(length(covs)-1)], "all")
negLogPs <- lapply(covs, function (covSet) {
mrs <- enetCombined$values
form <- if (covSet == "none") as.formula("event~mrs") else as.formula(paste0("event~mrs+",covSet))
mrsCovs.fit <- glm(form, family="binomial", data=non_meth_data, subset=testset)
negLogP <- -log10(2*pnorm(-abs(summary(mrsCovs.fit)$coef["mrs","z value"])))
negLogP
})

negLogPs.df <- data.frame(covariate=factor(names(covs), levels=names(covs)), negLogP=unlist(negLogPs))

ggplot(negLogPs.df, aes(x=covariate, y="", fill=negLogP)) + 
geom_tile() +
scale_fill_gradient2(low='#0000FF',mid='#FFFFFF',high='#FF0000') +
coord_fixed(ratio=1) +
ggtitle("P-values for MRS after adjustment for covariate(s)") +
theme(axis.title=element_blank(), axis.text.x=element_text(angle=30))

non_meth_data$mrs <- enetCombined$values
mrs_resids <- lm(as.formula(paste0("mrs~",covs["all"])), data=non_meth_data)$residuals
adjROC <- roc(non_meth_data$event[testset], mrs_resids[testset])
```


## Specific CpG components/weights

```{r cpg-literature, eval=F}
cpg_custom_annotations <- c(
cg09741592="smoking",
cg18181703="metabolic syndrome",
cg00534468="cholesterol efflux capacity",
cg16867657="aging (strongly)",
cg19693031="T2D",
cg00854392="high-fat overfeeding in subQ AT",
cg23287661="T2D in AT",
cg23289079="cancer"
)
cpg_custom_annotations_DF <- tibble(CpG=names(cpg_custom_annotations), "Literature association"=cpg_custom_annotations)
```

```{r mrs-components, eval=F}
components <- enetCombined$components
components <- components[components!=0]
componentsDF <- tibble(CpG=names(components), weight=components) %>%
inner_join(cpg_to_gene, by=c("CpG"="cpg")) %>%
left_join(cpg_custom_annotations_DF, by="CpG") %>%
replace_na(list(`Literature association`="")) %>%
arrange(desc(abs(weight)))
kable(componentsDF, caption="MRS components CpGs and associated genes")
```

## ...the catch, or "Batch effects: 1, Kenny: 0"

```{r 2enet-combined, eval=F}
cl <- makePSOCKcluster(5)
registerDoParallel(cl)
cpacor_adj_model_withStudy <- paste0(cpacor_adj_model, "+study")
TwoenetCombined <- trainTestMRS(cpacor_adj_model_withStudy, non_meth_data, 
betas[beta_variances_trainset>quantile(beta_variances_trainset,0.75),],
trainset, testset, parallel=T)
stopCluster(cl)

TwoenetCombined_binTest <- test_mrs_binary(non_meth_data, TwoenetCombined$values, testset)
```

```{r study-adjust, eval=F}
mrsStudyResids <- lm(mrs~study, data=non_meth_data)$residuals
studyAdjROC <- roc(non_meth_data$event[testset], mrsStudyResids[testset])
```

It seems that I eventually got bitten by the class imbalance between FHS (mostly controls) and WHI (half cases) -- MRS residuals after adjustment for study lose much of their predictive power...

-# Alternate prediction strategies-

```{r gene-set-activations, cache.vars=c("msigdb","sig_to_cpgs","pca_from_cpg_set","geneSetLoadings","geneSetActivationsMat"), eval=F}
msigdb_file <- file("../data/misc/gsea/c2.cp.v6.0.symbols.gmt")  # MSigDB file from http://software.broadinstitute.org/gsea/msigdb/collections.jsp#C2
msigdb <- strsplit(readLines(msigdb_file), split="\t")  # File is tab-separated with gene lists immediately following their names and URLs
names(msigdb) <- purrr::map(msigdb, 1)  # First element of each msig vector is name
msigdb <- purrr::map(msigdb, function(sig) sig[-c(1,2)])  # No need for name or URL

genes_to_cpgs_df <- anno_450k %>%
dplyr::rename(gene=UCSC_RefGene_Name, cpg=Name) %>%
dplyr::select(gene, cpg) %>%
separate_rows(gene, sep=";") %>%
distinct() %>% 
filter(!is.na(gene), gene!="") %>%
nest(-gene) %>%
mutate(cpgs=purrr::map(data, function(d) unique(d$cpg))) %>%
dplyr::select(-data)
genes_to_cpgs <- setNames(genes_to_cpgs_df$cpgs, genes_to_cpgs_df$gene)  # List of associated CpGs on 450k array for each gene

sig_to_cpgs <- purrr::map(msigdb, function(sig) unique(unlist(genes_to_cpgs[sig])))

library(flashpcaR)

pca_from_cpg_set <- function(cpgs, testset) {
cpgs_trimmed <- cpgs[cpgs %in% rownames(betas)]
pcaMat <- t(betas[cpgs_trimmed,testset])
pca.fit <- flashpca(pcaMat, stand="sd", ndim=2, do_loadings=T)
pc1_loadings <- pca.fit$loadings[,1]
setNames(pc1_loadings, cpgs_trimmed)
}

geneSetLoadings <- lapply(sig_to_cpgs, pca_from_cpg_set, testset)

t_betas_scaled <- scale(t(betas))
geneSetActivations <- lapply(geneSetLoadings, function(loading) t_betas_scaled[,names(loading)] %*% loading)
geneSetActivationsMat <- do.call(cbind, geneSetActivations)
colnames(geneSetActivationsMat) <- names(geneSetActivations)
```

```{r gene-set-mrs, include=F, eval=F}
stopifnot(all(rownames(geneSetActivationsMat) == non_meth_data$sampleKey))
design_mat <- geneSetActivationsMat
cvd_surv <- Surv(time=non_meth_data$time, event=non_meth_data$event)
geneset.fit.cv <- cv.glmnet(design_mat[trainset,], cvd_surv[trainset], family="cox", alpha=0.5,  # Train MRS model
penalty.factor=ifelse(colnames(design_mat) %in% names(sig_to_cpgs), 1, 0), nfolds=5)
coefs <- coef(geneset.fit.cv, s="lambda.min")[,1]
coefs_meth <- coefs[coefs!=0 & (names(coefs) %in% names(sig_to_cpgs))]  # Methylation coefficients only
geneset_mrs_calc <- as.vector(design_mat[,names(coefs_meth)] %*% coefs_meth)  # Calculate the MRS for all samples
mrs_test <- test_mrs_binary(non_meth_data, geneset_mrs_calc, testset)
print(mrs_test)
```

```{r gene-set-rf, include=F, eval=F}
cl <- makePSOCKcluster(8)
registerDoParallel(cl)
rfGeneSetModel <- testTrain_RF(cpacor_adj_model, non_meth_data, t(geneSetActivationsMat), 
trainset, testset, ntree=80*8, ncores=8)
stopCluster(cl)

geneSetRF_binTest <- test_mrs_binary(non_meth_data, rfGeneSetModel$values, testset)
print(geneSetRF_binTest)
```









-
-->

<!--
# Below is old stuff
## Hypothesis-driven CpG sets based on WBC biology

```{r hypothesis-driven, eval=F}
# See how pre-selection of specific CpG sets affects model performance
print("Test pre-selected CpG sets with biological relevance...")
library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
mon_to_mac <- suppressWarnings(read_csv("../data/literature/mon_to_mac_DMRs_Wallner2016.csv")) %>%
filter(!is.na(Location)) %>%
mutate(chr=gsub(":.*", "", Location),
start=as.integer(gsub("-.*", "", gsub(".*:", "", Location))),
end=as.integer(gsub(".*-", "", Location))) %>%
select(chr, start, end)

mon_var_schroder <- read_csv("../data/literature/variable_monocyte_DMRs_Schroder2017.csv") %>%
mutate(chr=paste0("chr", gsub(":.*", "", location)),
start=as.integer(gsub("-.*", "", gsub(".*:", "", location))),
end=as.integer(gsub(".*-", "", location))) %>%
select(chr, start, end)

cpgAnnot <- Locations %>%
data.frame(stringsAsFactors=F) %>%
rownames_to_column(var="cpg")

mon_to_mac_cpgs <- inner_join(cpgAnnot, mon_to_mac, by="chr") %>%
filter(pos>=start, pos<=end)

mon_var_schroder_cpgs <- inner_join(cpgAnnot, mon_var_schroder, by="chr") %>%
filter(pos>=start, pos<=end)

# Read in Ecker variable CpGs (more than one sheet, each separately)
library(readxl)
variable_monSpecific <- read_excel("../data/literature/variable_cpgs_Ecker2017.xlsx", sheet="Monocytes")
variable_neutSpecific <- read_excel("../data/literature/variable_cpgs_Ecker2017.xlsx", sheet="Neutrophils")
variable_tcellSpecific <- read_excel("../data/literature/variable_cpgs_Ecker2017.xlsx", sheet="T cells")
variable_monNeutSpecific <- read_excel("../data/literature/variable_cpgs_Ecker2017.xlsx",
sheet="Monocytes + neutrophils")

# CVD GWAS SNP-based
library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
anno_450k <- data.frame(getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19), stringsAsFactors=F)
cvd_gwas_associations <- read_tsv("../data/literature/gwas-association-downloaded_2017-09-18-cardiovascular disease.tsv")
cvd_gwas_genes <- unique(unlist(strsplit(cvd_gwas_associations$`REPORTED GENE(S)`, split=", ")))

cvd_gwas_cpgs_by_pos <- cvd_gwas_associations %>%
mutate(chr=paste0("chr", CHR_ID),
snp_pos=CHR_POS) %>%
select(chr, snp_pos) %>%
inner_join(select(anno_450k, Name, chr, pos), by="chr") %>%
mutate(snp_pos=as.numeric(snp_pos)) %>%
filter(pos>=snp_pos-1000, pos<=snp_pos+1000) %>%
dplyr::rename(cpg=Name) %>%
distinct(cpg)

cvd_gwas_cpgs_byGene <- anno_450k %>%
filter(toupper(UCSC_RefGene_Name) %in% cvd_gwas_genes) %>%
dplyr::rename(cpg=Name) %>%
distinct(cpg)

trainTest_cpg_set <- function(cpg_set, cpg_setName) {
print(paste0(cpg_setName, " (", length(cpg_set), " CpGs)"))
kable(trainTestMRS(cpacor_adj_model, non_meth_data, betas[rownames(betas) %in% cpg_set,],
whiSet, fhsSet)$res)
}

trainTest_cpg_set(mon_to_mac_cpgs$cpg, "Monocyte-to-macrophage DMRs, Wallner 2016")
trainTest_cpg_set(mon_var_schroder_cpgs$cpg, "Variable CpGs in monocytes, Schroder 2017")
trainTest_cpg_set(variable_monSpecific$`Probe ID`, "Variable CpGs in monocytes only, Ecker 2017")
trainTest_cpg_set(variable_neutSpecific$`Probe ID`, "Variable CpGs in neutrophils only, Ecker 2017")
trainTest_cpg_set(variable_tcellSpecific$`Probe ID`, "Variable CpGs in T-cells only, Ecker 2017")
trainTest_cpg_set(variable_monNeutSpecific$`Probe ID`, "Variable CpGs in monocytes and neutrophils only, Ecker 2017")
trainTest_cpg_set(cvd_gwas_cpgs_by_pos$cpg, "CpGs +/- 1kb from GWAS catalog CVD SNPs")
trainTest_cpg_set(cvd_gwas_cpgs_byGene$cpg, 
"CpGs annotated to genes to which GWAS catalog CVD SNPs are annotated")
```

```{r gene-set-activations_old, eval=F}
msigdb_file <- file("../data/misc/gsea/c2.cp.v6.0.symbols.gmt")  # MSigDB file from http://software.broadinstitute.org/gsea/msigdb/collections.jsp#C2
msigdb <- strsplit(readLines(msigdb_file), split="\t")  # File is tab-separated with gene lists immediately following their names and URLs
names(msigdb) <- purrr::map(msigdb, 1)  # First element of each msig vector is name
msigdb <- purrr::map(msigdb, function(sig) sig[-c(1,2)])  # No need for name or URL

library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
annot <- data.frame(getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19), stringsAsFactors=F)
genes_to_cpgs_df <- annot %>%
dplyr::rename(gene=UCSC_RefGene_Name, cpg=Name) %>%
select(gene, cpg) %>%
separate_rows(gene, sep=";") %>%
distinct() %>% 
filter(!is.na(gene), gene!="") %>%
nest(-gene) %>%
mutate(cpgs=purrr::map(data, function(d) unique(d$cpg))) %>%
select(-data)
genes_to_cpgs <- setNames(genes_to_cpgs_df$cpgs, genes_to_cpgs_df$gene)  # List of associated CpGs on 450k array for each gene

sig_to_cpgs <- purrr::map(msigdb, function(sig) unique(unlist(genes_to_cpgs[sig])))

library(flashpcaR)

pca_from_cpg_set <- function(cpgs) {
cpgs_trimmed <- cpgs[cpgs %in% rownames(betas)]
pcaMat <- t(betas[cpgs_trimmed,])
pca.fit <- flashpca(pcaMat, stand="sd", ndim=2, do_loadings=T)
pc1_loadings <- pca.fit$loadings[,1]
setNames(pc1_loadings, cpgs_trimmed)
}

geneSetLoadings <- lapply(sig_to_cpgs, pca_from_cpg_set)

t_betas_scaled <- scale(t(betas))
geneSetActivations <- lapply(geneSetLoadings, function(loading) t_betas_scaled[,names(loading)] %*% loading)
geneSetActivationsMat <- do.call(cbind, geneSetActivations)
colnames(geneSetActivationsMat) <- names(geneSetActivations)
```

```{r gene-set-mrs_old, eval=F}
trainset <- which(non_meth_data$study == "whi")
testset <- which(non_meth_data$study == "fhs")

mod <- "~age+smk_now+CD4T+NK+Bcell+Mono+Gran+PC1_combat+PC2_combat"
covars_frame <- model.frame(mod, non_meth_data, na.action=na.pass)  # To allow NAs to pass through
covars_mat <- model.matrix(as.formula(mod), covars_frame)[,-1]  # Converts factors to numeric
stopifnot(all(rownames(geneSetActivationsMat) == non_meth_data$sampleKey))
design_mat <- cbind(covars_mat, geneSetActivationsMat)
cvd_surv <- Surv(time=non_meth_data$time, event=non_meth_data$event)
mrs_fit <- glmnet(design_mat[trainset,], cvd_surv[trainset], family="cox", alpha=0.5,  # Train MRS model
penalty.factor=ifelse(colnames(design_mat) %in% names(sig_to_cpgs), 1, 0))
coefs <- mrs_fit$beta[,ncol(mrs_fit$beta)]  # Extract coefficients
coefs_meth <- coefs[coefs!=0 & (names(coefs) %in% names(sig_to_cpgs))]  # Methylation coefficients only
mrs_calc <- as.vector(design_mat[,names(coefs_meth)] %*% coefs_meth)  # Calculate the MRS for all samples
mrs_test <- coxph(cvd_surv~mrs, data=cbind(cvd_surv=cvd_surv, mrs=mrs_calc,  # Test the predictivity of the MRS using a basic Cox model
non_meth_data), subset=testset)
hr_per_sd <- exp(sd(mrs_calc[testset])*summary(mrs_test)$coef[,"coef"])
print(cbind(HR_per_SD=hr_per_sd, p=summary(mrs_test)$coef[,"Pr(>|z|)"]))
```

```{r ewas-mrs-out, dependson=-1, eval=F}
ewasResTbl <- map_dfr(ewasmrs_res, function(res) data.frame(res$ewas)) %>%
mutate(numCpGsUsed=cpg_num, p=format(p, scientific=T))
ewasEnetResTbl <- map_dfr(ewasmrs_res, function(res) data.frame(matrix(res$ewasEnet,1,2))) %>%
setNames(c("HR_per_SD","p")) %>%
mutate(numCpGsUsed=cpg_num, p=format(p, scientific=T))

print("EWAS weighted sum approach:")
kable(ewasResTbl)
print("Elastic net regression on EWAS CpGs:")
kable(ewasEnetResTbl)
```


## Basic model -- train in WHI, test in FHS

```{r basic-model2, dependson="misc", eval=F}
print("Beta-values")
trainTestMRS(basic_model, non_meth_data, betas,
trainset=which(non_meth_data$study == "whi"),
testset=which(non_meth_data$study == "fhs"))$res

Mvals <- logit2(betas)
print("M-values")
trainTestMRS(basic_model, non_meth_data, Mvals,
trainset=which(non_meth_data$study == "whi"),
testset=which(non_meth_data$study == "fhs"))$res
rm(Mvals)

print("Test only in males")
trainTestMRS(basic_model, non_meth_data, betas,
trainset=which(non_meth_data$study == "whi"),
testset=which(non_meth_data$study == "fhs" & non_meth_data$sex == "M"))$res

print("Test only in females")
trainTestMRS(basic_model, non_meth_data, betas,
trainset=which(non_meth_data$study == "whi"),
testset=which(non_meth_data$study == "fhs" & non_meth_data$sex == "F"))$res

print("Train in FHS, test in WHI")
trainTestMRS(basic_model, non_meth_data, betas,
trainset=which(non_meth_data$study == "fhs"),
testset=which(non_meth_data$study == "whi"))$res
```

```{r basic-model-combatWO, eval=F}
betas_combatWO <- readRDS("../int/betas.qc.norm.filt.combat_eventAdj.rds")
print("With outcome-adjusted ComBat")
trainTestMRS(basic_model, non_meth_data, betas_combatWO,
trainset=which(non_meth_data$study == "whi"),
testset=which(non_meth_data$study == "fhs"))$res
rm(betas_combatWO)
```


```{r variance-thresholds-out, cache=F, eval=F}
kable(varThreshTbl)

ggplot(data=mutate(varThreshTbl, negLogP=-log(p)), 
aes(x=varThreshold, y=negLogP)) +
geom_point() + 
geom_line()
```

## Variance thresholds after ComBat

```{r VTC, eval=F}
library(flashpcaR)

betas_C <- readRDS("../int/betas.qc.norm.filt.combat.rds")
betas_C <- betas_C[,colnames(betas)]
beta_variances_C <- apply(betas_C[,non_meth_data$study == "whi"], 1, var)

print("25 and 75 %iles of variance threshold with basic ComBat")
varThresh_C <- quantile(beta_variances_C, probs=c(0.25,0.75))
varThreshRes_C <- lapply(varThresh_C, function(thresh) {
trainTestMRS(basic_model, non_meth_data, betas_C[beta_variances_C>thresh,],
which(non_meth_data$study == "whi"),
which(non_meth_data$study == "fhs"))
})
varThreshTbl_C <- map_dfr(varThreshRes_C, function(res) data.frame(res$res)) %>%
mutate(varThreshold=varThresh_C)

kable(varThreshTbl_C)
rm(betas_C)

betas_CE <- readRDS("../int/betas.qc.norm.filt.combat_eventAdj.rds")
betas_CE <- betas_CE[,colnames(betas)]
beta_variances_CE <- apply(betas_CE[,non_meth_data$study == "whi"], 1, var)

print("25 and 75 %iles of variance threshold with outcome-adjusted ComBat")
varThresh_CE <- quantile(beta_variances_CE, probs=c(0.25,0.75))
varThreshRes_CE <- lapply(varThresh_CE, function(thresh) {
trainTestMRS(basic_model, non_meth_data, betas_CE[beta_variances_CE>thresh,],
which(non_meth_data$study == "whi"),
which(non_meth_data$study == "fhs"))
})
varThreshTbl_CE <- map_dfr(varThreshRes_CE, function(res) data.frame(res$res)) %>%
mutate(varThreshold=varThresh_CE)

kable(varThreshTbl_CE)
rm(betas_CE)
```


## Within-study testing and training
```{r within-study, eval=F}
# Define train/test split
print("FHS only with variance threshold of 75th percentile")
set.seed(1)
nmd_fhs <- non_meth_data[non_meth_data$study == "fhs",]
trainset <- createDataPartition(factor(nmd_fhs$event), p=0.6)[[1]]  # Set up train/test partition
testset <- setdiff(1:nrow(nmd_fhs), trainset)
kable(trainTestMRS(basic_model, nmd_fhs, 
betas[beta_variances>quantile(beta_variances, 0.75),non_meth_data$study == "fhs"],
trainset, testset)$res)

print("FHS only with variance threshold of 75th percentile")
set.seed(1)
nmd_whi <- non_meth_data[non_meth_data$study == "whi",]
trainset <- createDataPartition(factor(nmd_whi$event), p=0.6)[[1]]  # Set up train/test partition
testset <- setdiff(1:nrow(nmd_whi), trainset)
kable(trainTestMRS(basic_model, nmd_whi, 
betas[beta_variances>quantile(beta_variances, 0.75),non_meth_data$study == "whi"],
trainset, testset)$res)
```

## What about random sets of 500 CpGs for comparison?
```{r random-cpg-sets, eval=F}
set.seed(1)
randomSets <- lapply(1:5, function(iter) 
trainTestMRS(basic_model, non_meth_data, Mvals[sample(1:nrow(Mvals), 500),], trainset, testset))
randomSetsRes <- map_dfr(randomSets, function(set) data.frame(set$res))
```

```{r random-cpg-sets-out, dependson=-1, eval=F}
kable(randomSetsRes)
```



## Male/female differences
```{r male-female, eval=F}
maleTrainSet <- trainset[non_meth_data$sex[trainset] == "M"]
femaleTrainSet <- trainset[non_meth_data$sex[trainset] == "F"] 
maleTestSet <- testset[non_meth_data$sex[testset] == "M"]
femaleTestSet <- testset[non_meth_data$sex[testset] == "F"]
print(paste0("Train on males only (n = ", length(maleTrainSet), "), then test on..."))

print(paste0("Males (n = ", length(maleTestSet), "):"))
res <- trainTestMRS(basic_model, non_meth_data, Mvals[Mval_variances>0.4,], maleTrainSet, maleTestSet)
print(res$res)
print(paste0("Females (n = ", length(femaleTestSet), "):"))
res <- trainTestMRS(basic_model, non_meth_data, Mvals[Mval_variances>0.4,], maleTrainSet, femaleTestSet)
print(res$res)

print(paste0("Train on females only (n = ", length(femaleTrainSet), "), then test on..."))
print(paste0("Males (n = ", length(maleTestSet), "):"))
res <- trainTestMRS(basic_model, non_meth_data, Mvals[Mval_variances>0.4,], femaleTrainSet, maleTestSet)
print(res$res)
print(paste0("Females (n = ", length(femaleTestSet), "):"))
res <- trainTestMRS(basic_model, non_meth_data, Mvals[Mval_variances>0.4,], femaleTrainSet, femaleTestSet)
print(res$res)
```

## Stability of the MRS in duplicate samples

```{r mrs-stability-old, eval=F}
print("ICC of the MRS (trained on entire dataset):")
res <- trainTestMRS(basic_model, non_meth_data, Mvals[Mval_variances>0.4,],
trainset=seq(1,nrow(non_meth_data)), testset=seq(1,nrow(non_meth_data)))
mrsValues <- t(Mvals_full[names(res$components),]) %*% res$components
library(ICC)
metaData <- readRDS("../int/metaData.rds")
iccData <- data.frame(shareid=factor(metaData$shareid[match(colnames(Mvals_full), metaData$sampleKey)]),
mrs=mrsValues)
icc_res <- ICCest(x=shareid, y=mrs, data=iccData)
print(icc_res$ICC)
```



-->

## Tentative conclusions

* A variance threshold of 50% reaches an approximate asymptote in performance while keeping the computational burden under control.
* There is not strong evidence to suggest that a change in alpha from 0.5 will provide notably better performance.
* The LBC datasets are complicated: they are somewhat older, and have non-intuitive relationships between traditional CVD risk factors and CVD prevalence/incidence. At the very least, the two cohorts (1921 and 1936) should be modeled separately.

# Genetic risk in the same cohorts

A genetic risk score (GRS) was calculated based on the model used by Khera et al. 2016 -- currently, ~48 of the 50 constituent genotypes are available for entry into the model. This GRS was first tested to confirm its associations in these datasets (genotypes available for WHI and FHS). While all CVD cases are incident in WHI, past and incident events were merged into a single binary variable for FHS in order to test the GRS.

```{r calc-grs, message=F, warning=F}
source("helpers.R")

genotype.df.fhs <- read_table2("../int/grs_genos/grs_genos_fhs.vcf", skip=6)
grs_df.fhs <- tibble(subjID=as.character(colnames(genotype.df.fhs)[-(1:9)]),
                     grs=calc_khera2016grs(genotype.df.fhs))

genotype.df.whi <- read_table2("../int/grs_genos/grs_genos_whi.vcf", skip=6)
imputedSampleInfo_whi <- read_tsv("../data/whi/gen/imputedSampleInfo.txt", skip=15)
grs.ids.whi <- imputedSampleInfo_whi$SubjectID[match(colnames(genotype.df.whi)[-(1:9)],
                                                     imputedSampleInfo_whi$SampleID)]

grs_df.whi <- tibble(subjID=as.character(grs.ids.whi), 
                     grs=calc_khera2016grs(genotype.df.whi))

grs_df <- bind_rows(grs_df.fhs, grs_df.whi)

# genotype.df <- read_csv("../int/cvd_grs_genos.csv")
# genotype.mat <- as.matrix(genotype.df[-1])
# grs_df <- tibble(subjID=as.character(genotype.df[[1]]), grs=calc_khera2016grs(genotype.mat))
```

```{r test-grs}
whi_grs_test_df <- left_join(nmd_whi, grs_df, by="subjID") %>%
  distinct(subjID, .keep_all=T)
grsRes.whi <- test_grs(whi_grs_test_df)

fhs_grs_test_df <- nmd_fhs %>%
  left_join(grs_df, by="subjID") %>%
  mutate(event=pastEvent | event)
grsRes.fhs <- test_grs(fhs_grs_test_df)

kable(bind_rows(list(WHI=grsRes.whi, FHS=grsRes.fhs), .id="cohort"), caption="GRS results")
```

# MRS performance across demographic and risk-based strata

Also worth checking this in REGICOR.

## Across sexes

```{r whi-mrs-to-fhs-sex}
mrs_fhs <- calc_mrs_glmnet(mrs_fit_whi$cpg_coefs, betas_fhs)
mrs_res_fhs_male <- test_mrs(filter(nmd_fhs, sex == "M"), 
                             mrs_fhs[nmd_fhs$sex == "M"])
mrs_res_fhs_female <- test_mrs(filter(nmd_fhs, sex == "F"), 
                               mrs_fhs[nmd_fhs$sex == "F"])
kable(bind_rows(list(Male=mrs_res_fhs_male, Female=mrs_res_fhs_female),
                .id="Sex"), 
      caption="WHI -> FHS sex-stratified")
```

```{r double-mrs-to-double-sex}
relevant_betas <- t(
  design_mat_whiFhs[, grepl("^cg", colnames(design_mat_whiFhs))])
mrs_whiFhs <- calc_mrs_glmnet(mrs_fit_whiFhs_full$cpg_coefs, relevant_betas)
mrs_res_whiFhs_male <- test_mrs(filter(nmd_whiFhs, sex == "M"), 
                                mrs_whiFhs[nmd_whiFhs$sex == "M"])
mrs_res_whiFhs_female <- test_mrs(filter(nmd_whiFhs, sex == "F"), 
                                  mrs_whiFhs[nmd_whiFhs$sex == "F"])
kable(bind_rows(list(Male=mrs_res_whiFhs_male, Female=mrs_res_whiFhs_female), 
                .id="Sex"), 
      caption="WHI + FHS -> WHI + FHS sex-stratified (Note: doesn't use an external validation set)")
```

## Based on race

```{r fhs-mrs-to-whi-race}
mrs_whi <- calc_mrs_glmnet(mrs_fit_fhs$cpg_coefs, betas_whi)
mrs_res_whi_white <- test_mrs(filter(nmd_whi, race == "white"), 
                              mrs_whi[nmd_whi$race == "white"])
mrs_res_whi_black <- test_mrs(filter(nmd_whi, race == "black"), 
                              mrs_whi[nmd_whi$race == "black"])
mrs_res_whi_hispanic <- test_mrs(filter(nmd_whi, race == "hispanic"), 
                                 mrs_whi[nmd_whi$race == "hispanic"])
kable(bind_rows(list(White=mrs_res_whi_white, Black=mrs_res_whi_black, 
                     Hispanic=mrs_res_whi_hispanic),
                .id="Race"), caption="FHS -> WHI race-stratified")
```

## Based on history of CVD

```{r whi-mrs-to-fhs-past-event}
mrs_fhs <- calc_mrs_glmnet(mrs_fit_whi$cpg_coefs, betas_fhs)
mrs_res_fhs_pastEvent <- test_mrs(filter(nmd_fhs, pastEvent == T), 
                                  mrs_fhs[nmd_fhs$pastEvent == T])
mrs_res_fhs_noPastEvent <- test_mrs(filter(nmd_fhs, pastEvent == F), 
                                    mrs_fhs[nmd_fhs$pastEvent == F])
kable(bind_rows(list(Yes=mrs_res_fhs_pastEvent, No=mrs_res_fhs_noPastEvent), 
                .id="Past event"), 
      caption="WHI -> FHS stratified by history of CVD")
```

## Across tertiles of genetic risk

```{r whi-mrs-to-fhs-grs-tertiles}
fhs_grs_tertile_cuts <- quantile(fhs_grs_test_df$grs, c(0.333, 0.666), na.rm=T)
mrs_fhs <- calc_mrs_glmnet(mrs_fit_whi$cpg_coefs, betas_fhs)

fhs_by_grs <- fhs_grs_test_df %>%
  mutate(mrs=mrs_fhs,
         tertile=findInterval(grs, fhs_grs_tertile_cuts) + 1) %>%
  nest(-tertile)
fhs_grs_tert_res <- map(fhs_by_grs$data, function(d) test_mrs(d, d$mrs))
names(fhs_grs_tert_res) <- as.character(1:3)
kable(bind_rows(fhs_grs_tert_res, .id="Tertile"), 
      caption="WHI -> FHS stratified by genetic risk score")
```

```{r fhs-mrs-to-whi-grs-tertiles}
whi_grs_tertile_cuts <- quantile(whi_grs_test_df$grs, c(0.333,0.666), na.rm=T)
mrs_whi <- calc_mrs_glmnet(mrs_fit_fhs$cpg_coefs, betas_whi)

whi_by_grs <- whi_grs_test_df %>%
  mutate(mrs=mrs_whi,
         tertile=findInterval(grs, whi_grs_tertile_cuts) + 1) %>%
  nest(-tertile)
whi_grs_tert_res <- map(whi_by_grs$data, function(d) test_mrs(d, d$mrs))
names(whi_grs_tert_res) <- as.character(1:3)
kable(bind_rows(whi_grs_tert_res, .id="Tertile"), 
      caption="FHS -> WHI stratified by genetic risk score")
```

# MRS stability

```{r mrs-stability, cache=1, cache.vars=c("meta_lbc36_with_dups","icc_res")}
betas_lbc36_with_dups <- readRDS("../int/betas.qc.norm.filt_lbc.rds")
meta_lbc36_with_dups <- readRDS("../int/metaData.rds") %>%
  filter(study == "lbc36",
         sampleKey %in% colnames(betas_lbc36_with_dups))
betas_lbc36_with_dups <- betas_lbc36_with_dups[, meta_lbc36_with_dups$sampleKey]

library(ICC)
meta_lbc36_with_dups$mrs <- calc_mrs_glmnet(mrs_fit_whiFhs_full$cpg_coefs, 
                                            betas_lbc36_with_dups)
icc_res <- ICCest(x=subjID, y=mrs, data=meta_lbc36_with_dups)
print(paste("ICC:", icc_res$ICC))

#############################

# print("ICC of the MRS (trained on entire dataset):")
# res <- trainTestMRS(basic_model, non_meth_data, Mvals[Mval_variances>0.4,],
#                     trainset=seq(1,nrow(non_meth_data)), testset=seq(1,nrow(non_meth_data)))
# mrsValues <- t(Mvals_full[names(res$components),]) %*% res$components
# library(ICC)
# metaData <- readRDS("../int/metaData.rds")
# iccData <- data.frame(shareid=factor(metaData$shareid[match(colnames(Mvals_full), metaData$sampleKey)]),
#                       mrs=mrsValues)
# icc_res <- ICCest(x=shareid, y=mrs, data=iccData)
# print(icc_res$ICC)
```

# Validation of MRS with respect to prevalent CVD (MI) in REGICOR

Quite predictive alone and with adjustment for cell counts/technical factors/smoking, marginally significant in the presence of traditional risk factors.

# GWIS with MRS

# EWIS with GRS

```{r ewis-prep}
my_try <- function(expr, CpG) {
  # Captures model failures and returns successful result or vector of NAs
  tryCatch(expr,
           error = function(e) {print(e); return(c(CpG, rep(NA, 3)))})
}

run_cox_model_interaction <- function(probe_data, covar_data, model_spec) {
  # Given a row of the M-value matrix (corresponding to a CpG site), bind that methylation
  # data to the covariate data and run Cox proportional hazards regression
  CpG <- rownames(probe_data)
  probe_data <- as.vector(probe_data)
  outlierTF <- (probe_data < quantile(probe_data,0.25) - 3 * IQR(probe_data) | 
    probe_data > quantile(probe_data, 0.75) + 3 * IQR(probe_data))
  model_data <- cbind(covar_data, meth=as.numeric(probe_data),
                     survObj=Surv(time=covar_data$time, event=covar_data$event))
  my_try({
    cox_fit <- coxph(as.formula(model_spec), data=model_data, subset=!outlierTF)
    c(CpG=CpG, summary(cox_fit)$coef['meth:grs', c('coef', 'z', 'Pr(>|z|)')])
  }, CpG)
}
```

```{r ewis-whi, cache=1}
ewis_model_whi <- paste0("survObj~meth*grs+race+age+bmi+smk_now+smk_py+CD4T+",
                         "CD8T+Bcell+NK+Mono+Gran+dnaPull")

cl <- makePSOCKcluster(detectCores())
registerDoParallel(cl)

ewis_res_whi_list <- foreach(meth=iter(betas_whi, by="row"), 
                            .packages="survival") %dopar%
  run_cox_model_interaction(meth, whi_grs_test_df, ewis_model_whi)

stopCluster(cl)

ewis_res_whi <- do.call(rbind, ewis_res_whi_list) %>%
  data.frame(stringsAsFactors=F, check.names=F) %>%
  dplyr::rename(p=`Pr(>|z|)`) %>%
  mutate_at(c("coef", "z", "p"), as.numeric) %>%
  mutate(fdr=p.adjust(p, method="BH")) %>%
  arrange(p)
```

```{r ewis-fhs, cache=1}
ewisModel_fhs <- paste0("survObj~meth*grs+sex+age+bmi+smk_now+smk_py+CD4T",
                        "+CD8T+Bcell+NK+Mono+Gran+center+",
                        paste0("cpPC",1:7,collapse="+"))

cl <- makePSOCKcluster(detectCores())
registerDoParallel(cl)

ewis_res_fhs_list <- foreach(meth=iter(betas_fhs, by="row"), 
                             .packages="survival") %dopar%
  run_cox_model_interaction(meth, fhs_grs_test_df, ewisModel_fhs)

stopCluster(cl)

ewis_res_fhs <- do.call(rbind, ewis_res_fhs_list) %>%
  data.frame(stringsAsFactors=F, check.names=F) %>%
  dplyr::rename(p=`Pr(>|z|)`) %>%
  mutate_at(c("coef", "z", "p"), as.numeric) %>%
  mutate(fdr=p.adjust(p, method="BH")) %>%
  arrange(p)
```

```{r print-temp}
kable(head(ewis_res_whi, 10), caption="EWIS results in WHI")
kable(head(ewis_res_fhs, 10), caption="EWIS results in FHS")
```


# Full modeling of genetic plus epigenetic risk

Start with a standard ML model (random forest for example?) and try:

* Methylation only
* Genotypes only
* Risk factors only
* All three together
* Different groups of two depending on the results