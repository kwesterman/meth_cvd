---
title: MRS Model Experimentation
output:
  pdf_document:
    latex_engine: pdflatex
---

```{r prereqs, include=F, cache=F}
library(knitr)
opts_chunk$set(echo=F, cache.lazy=F, cache.path="../cache/mrs_models/",
               fig.keep="high", fig.path="../doc/mrs_models/figures/")
suppressMessages(silent <- lapply(
  c("tidyverse", "survival", "glmnet", "minfi", "caret", "doParallel",
    "itertools", "randomForest", "pROC", "ICC", "cowplot"), 
  library, character.only=T))
options(digits=3)
```

```{r load-data}
# Load methylation data
betas_whi <- readRDS("../int/betas.qc.norm.filt_whi.rds")
betas_fhs <- readRDS("../int/betas.qc.norm.filt_fhs.rds")
betas_lbc <- readRDS("../int/betas.qc.norm.filt_lbc.rds")

# Load metadata
metaData <- readRDS("../int/metaData.rds")

# Load estimated cell counts
est_cell_counts_whi <- readRDS("../int/est_cell_counts_whi.rds")
est_cell_counts_fhs <- readRDS("../int/est_cell_counts_fhs.rds")
est_cell_counts_lbc <- readRDS("../int/est_cell_counts_lbc.rds")

# Load CPACOR principal component adjustment factors
load("../int/CPACOR_whi.RData")
CP_PCs_whi <- CP_PCs
load("../int/CPACOR_fhs.RData")
CP_PCs_fhs <- CP_PCs
load("../int/CPACOR_lbc.RData")
CP_PCs_lbc <- CP_PCs

# Load PCA results
load("../int/PCA.fit_whi.RData")
PCs_whi <- PCs
load("../int/PCA.fit_fhs.RData")
PCs_fhs <- PCs
load("../int/PCA.fit_lbc.RData")
PCs_lbc <- PCs

# Load Illumina 450k annotation
library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
anno_450k <- data.frame(
  getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19), 
  stringsAsFactors=F)
```

```{r clean-data, warning=F}
est_cell_counts <- bind_rows(est_cell_counts_whi, est_cell_counts_fhs, 
                             est_cell_counts_lbc)
CP_PCs <- bind_rows(CP_PCs_whi, CP_PCs_fhs, CP_PCs_lbc)
PCs <- bind_rows(PCs_whi, PCs_fhs, PCs_lbc)

### Create master covariate/event data frame
non_meth_data <- Reduce(function(x,y) inner_join(x, y, by="sampleKey"), 
                        list(metaData, est_cell_counts, CP_PCs, PCs)) %>%
  filter(is.na(wave) | wave == 1) %>%
  distinct(subjID, .keep_all=T)  # Better way of deciding which biological replicates to keep?
# non_meth_data <- replace_na(non_meth_data, 
#                           list(bmi=median(non_meth_data$bmi, na.rm=T),
#                                smk_now=0, smk_py=0, ht_med=0, lipid_med=0, dm_med=0)) %>%
#   mutate(diabetes=dm_med | glu>125) %>%
#   mutate_at(c("chol","ldl","hdl","tg","sbp","glu","hscrp"), log10)
### THINK MORE ABOUT ABOVE WRANGLING ###

nmd_whi <- filter(non_meth_data, study == "whi")
nmd_fhs <- filter(non_meth_data, study == "fhs")
nmd_lbc36 <- filter(non_meth_data, study == "lbc36")

betas_whi <- betas_whi[, nmd_whi$sampleKey]
betas_fhs <- betas_fhs[, nmd_fhs$sampleKey]
betas_lbc36 <- betas_lbc[, nmd_lbc36$sampleKey]
stopifnot(all(colnames(betas_whi) == nmd_whi$sampleKey),
          all(colnames(betas_fhs) == nmd_fhs$sampleKey),
          all(colnames(betas_lbc36) == nmd_lbc36$sampleKey))  # Ensure identical number and order of samples for methylation and covariate data
```

```{r screening-funcs}
my_try <- function(expr, CpG) {
  # Captures model failures and returns successful result or vector of NAs
  tryCatch(expr,
           error = function(e) {print(e); return(c(CpG, rep(NA, 3)))})
}

run_cox_model <- function(probe_data, covar_data, model_spec) {
  # Given a row of the M-value matrix (corresponding to a CpG site), bind that methylation
  # data to the covariate data and run Cox proportional hazards regression
  CpG <- rownames(probe_data)
  probe_data <- as.vector(probe_data)
  # outlierTF <- probe_data < quantile(probe_data ,0.25) - 3 * IQR(probe_data) | 
  #   probe_data > quantile(probe_data, 0.75) + 3 * IQR(probe_data)
  model_data <- cbind(covar_data, meth=as.numeric(probe_data),
                     surv_obj=Surv(time=covar_data$time, event=covar_data$event))
  my_try({
    cox_fit <- coxph(as.formula(model_spec), data=model_data)
    c(CpG=CpG, summary(cox_fit)$coef[c('meth'), 
                                     c('coef', 'z', 'Pr(>|z|)')])
  }, CpG)
}
```

```{r train-test-funcs}
construct_design_mat <- function(cpgs, betas, covars, meta) {
  covar_formula <- as.formula(paste("~", paste(covars, collapse="+")))
  covars_frame <- model.frame(covar_formula, meta, na.action=na.pass)  # To allow NAs to pass through
  covars_mat <- model.matrix(covar_formula, covars_frame)[,-1]  # Converts factors to numeric
  cbind(covars_mat, t(betas[cpgs,]))
}

test_mrs <- function(meta, mrs, subset=NULL, return_fit=F,
                     covars=c()) {
  meta$mrs <- scale(mrs)
  meta$cvd_surv <- Surv(time=meta$time, event=meta$event)  # Outcome
  covar_string <- "cvd_surv ~ mrs"
  if (length(covars) > 0) {
    covar_string <- paste(covar_string, "+", paste(covars, collapse=" + "))
  } 
  form <- as.formula(paste(c("cvd_surv ~ mrs", covars), collapse=" + "))
  mrs_test <- coxph(form, data=meta, subset=subset)  # Test the MRS using a Cox model
  mrs_res <- summary(mrs_test)$coef["mrs",c("exp(coef)","z")]
  mrs_res_tbl <- tibble(HR_per_SD=mrs_res["exp(coef)"], 
                        p=2 * pnorm(-abs(mrs_res["z"])))
  if (return_fit) {
    list(fit=mrs_test, tbl=mrs_res_tbl) 
  } else {
    mrs_res_tbl
  }
}

test_grs <- function(grs_df) {
  # grs_df input should have both event data and a column names "grs"
  grs_df$grs <- scale(grs_df$grs)
  grs_test <- glm(event ~ grs, data=grs_df, family="binomial")
  grs_res <- summary(grs_test)$coef["grs",c("Estimate","z value")]
  tibble(OR_per_SD=exp(grs_res["Estimate"]), p=2 * pnorm(-abs(grs_res["z value"])))
}

format_p_vals <- function(tbl) {
  if(any(colnames(tbl) == "p")) {
    tbl <- mutate(tbl, p=case_when(p > 0.1 ~ round(p, 2),
                                   p > 0.001 ~ signif(p, 2),
                                   TRUE ~ format(p, digits=2, scientific=T)))
  }
  tbl
}

# trainTestMRS <- function(mod, meta, meth, trainset, testset, alpha=0.5, nfolds=5, lmr=0.1, lt="lambda.min", parallel=F) {
#   mrs_fit <- train_mrs(mod, meta, meth, trainset, alpha=alpha, nfolds=nfolds, lmr=lmr, lambda.type=lt, parallel=parallel)
#   mrs_values <- calc_mrs(mrs_fit$cpg_coefs, meth)
#   mrs_test <- tryCatch(test_mrs(meta, mrs_values, testset), error=function(e) matrix(NA, 1, 2))
#   list(fit=mrs_fit, components=mrs_fit$cpg_coefs, values=mrs_values, res=mrs_test)
# }
```

```{r glmnet-funcs}
train_glmnet <- function(X, y, alpha=0.5, nfolds=5, lmr=0.01,
                         parallel=F, s="lambda.min") {
  mrs_fit_cv <- cv.glmnet(X, y, family="cox", alpha=alpha,  # Train MRS model
                          penalty.factor=ifelse(grepl("^cg", colnames(X)), 1, 0),
                          lambda.min.ratio=lmr,
                          nfolds=nfolds, parallel=parallel)
  coefs <- coef(mrs_fit_cv, s=s)
  cpg_coefs <- coefs[grepl("^cg", rownames(coefs)),]
  list(fit=mrs_fit_cv,  # Output is a list containing the model fit and the CpG model coefficients
       all_coefs=coefs,
       cpg_coefs=cpg_coefs)
}

calc_mrs_glmnet <- function(coefs, meth) {
  if (length(coefs) == 0 || all(coefs == 0)) {
    message("No non-zero coefficients")
    return(rep(NA, ncol(meth)))
  } else {
    nonzero_coefs <- coefs[coefs!=0]
    usefulCoefs <- nonzero_coefs[names(nonzero_coefs) %in% rownames(meth)]
    as.vector(t(meth[names(usefulCoefs), , drop=F]) %*% usefulCoefs)
  }
}  
```

## Methylation risk score construction

```{r train-test-setup}
nmd_all <- bind_rows(nmd_whi, nmd_fhs, nmd_lbc36) %>%
  mutate(batch=case_when(study == "whi" ~ "whi",
                         study == "lbc36" ~ "lbc36",
                         TRUE ~ paste0("fhs_", center)))
cvd_surv_all <- Surv(nmd_all$time, nmd_all$event)

common_cpgs <- Reduce(intersect, list(rownames(betas_whi),
                                      rownames(betas_fhs),
                                      rownames(betas_lbc36)))
betas_all <- cbind(betas_whi[common_cpgs, ],
                   betas_fhs[common_cpgs, ],
                   betas_lbc36[common_cpgs, ])

set.seed(1)
train_val_set <- createDataPartition(factor(nmd_all$event), p=0.75)[[1]]
trainset_idx <- createDataPartition(
  factor(nmd_all$event[train_val_set]), p=0.66)[[1]]
trainset <- train_val_set[trainset_idx]
# trainset <- sample(train_val_set, size=floor(0.5 * nrow(nmd_all)))
validationset <- setdiff(train_val_set, trainset)
testset <- seq(1, nrow(nmd_all))[-train_val_set]
```

Basic setup:

* Combine WHI/FHS/LBC36 and split into 50% training, 25% validation, and 25% testing
* Test marginal associations of each CpG with incident CVD (training set)
* Grid search over parameters for elastic net (# top CpGs, alpha) (training set, evaluate in validation set)
* Train tuned model in training + validation set and evaluate performance in test set

### Initial EWAS-like screening using marginal associations

```{r screening, cache=1}
cl <- makePSOCKcluster(32)
registerDoParallel(cl)

marginal_res_list <- foreach(meth=iter(betas_all, by="row"), 
                              .packages="survival") %dopar%
  run_cox_model(meth[, trainset, drop=F], nmd_all[trainset, ], 
                "surv_obj ~ meth + batch")

stopCluster(cl)
```

```{r screening-processing}
marginal_res <- do.call(rbind, marginal_res_list) %>%
  data.frame(stringsAsFactors=F, check.names=F) %>%
  dplyr::rename(p=`Pr(>|z|)`) %>%
  mutate_at(c("coef","z","p"), as.numeric) %>%
  mutate(fdr=p.adjust(p, method="BH")) %>%
  arrange(p)
```

### Tuning

```{r grid-search, cache=1}
cpg_nums <- c(100, 500, 1000, 2000, 3000, 4000, 5000)
alphas <- c(0, 0.25, 0.5, 0.75, 1)

cl <- makePSOCKcluster(3)
registerDoParallel(cl)

param_grid <- expand.grid(num_features=cpg_nums, alpha=alphas)
grid_fits_list <- apply(param_grid, 1, function(row) {
  design_mat <- construct_design_mat(
    marginal_res$CpG[1:row[["num_features"]]], betas_all, "batch", nmd_all)
  train_glmnet(design_mat[trainset, ], cvd_surv_all[trainset],
               alpha=row[["alpha"]], nfolds=3, parallel=T)
})

stopCluster(cl)
```

```{r test-grid}
grid_res_list <- lapply(grid_fits_list, function(fit) {
  mrs <- calc_mrs_glmnet(fit$cpg_coefs, betas_all)
  mrs_test <- test_mrs(nmd_all[validationset, ], mrs[validationset])
  mrs_test
})
grid_res_df <- cbind(param_grid, bind_rows(grid_res_list))

grid_plot_data <- grid_res_df %>%
  mutate(negLogP=-log10(p)) %>%
  dplyr::select(num_features, alpha, HR_per_SD, negLogP)
  # gather(key=metric, value=value, HR_per_SD, negLogP)

ggplot(grid_plot_data, aes(x=alpha, y=log10(num_features), 
                           color=negLogP, size=HR_per_SD)) + 
  geom_point(alpha=0.8) +
  # scale_color_continuous(limits=c(0, NA)) +
  scale_size_continuous(limits=c(1, NA)) +
  # geom_line() +
  labs(x="Elastic net alpha parameter")
  # facet_wrap(~metric, nrow=2, scales="free") +
  # theme(axis.title.y=element_blank())
```

A grid search suggests that performance is optimized with an alpha parameter of zero (i.e. ridge regression) and use of the top 2000 CpG sites based on marginal associations with incident CVD. Using these parameters, a model was trained in the combined training + validation sets and tested on the fully held-out portion of the dataset.

### Testing

```{r tuned-model, cache=1}
tuned_design_mat <- construct_design_mat(marginal_res$CpG[1:2000],
                                         betas_all, "batch", nmd_all)

cl <- makePSOCKcluster(10)
registerDoParallel(cl)

tuned_mrs_fit <- train_glmnet(tuned_design_mat[train_val_set, ],
                              cvd_surv_all[train_val_set],
                              alpha=0, nfolds=10)

stopCluster(cl)
```

```{r test-tuned-model, warning=F}
mrs_tuned <- calc_mrs_glmnet(tuned_mrs_fit$cpg_coefs, betas_all)

nmd_all$diabetes <- nmd_all$dm_med | (nmd_all$glu > 125)
nmd_test <- nmd_all[testset, ]
mrs_tuned_test <- mrs_tuned[testset]

covar_sets <- list(
  none=c(),
  age_sex=c("age", "sex"),
  plus_cell_counts=c("age", "sex", "CD4T", "CD8T", "NK", "Bcell", "Mono", "Gran"),
  plus_bmi=c("age", "sex", "bmi"),
  plus_diabetes=c("age", "sex", "diabetes"),
  plus_smoking=c("age", "sex", "smk_now", "smk_py"),
  plus_lipids_sbp=c("age", "sex", "ldl", "hdl", "tg", "sbp"),
  full_model=c("age", "sex", "CD4T", "CD8T", "NK", "Bcell", "Mono", "Gran",
               "bmi", "diabetes", "smk_now", "smk_py", "ldl", "hdl", "tg", "sbp"))

test_metrics_tbl <- map_dfr(
  covar_sets, function(cs) test_mrs(nmd_test, mrs_tuned_test, covars=cs),
  .id="Covariate_set")

kable(test_metrics_tbl, caption="Performance of the MRS in the held-out test set.")
```

```{r evaluation, cache=F, eval=F}
source("helpers.R")

run_mrs_lr <- function(dat, mrs_values) {
  dat$mrs <- scale(mrs_values)
  dat <- dat %>%
    mutate(diabetes=dm_med|glu>125) %>%
    replace_na(list(diabetes=F))
  dat$frs <- calc_FRS(dat)
  testset <- which(dat$study == "fhs" & !is.na(dat$frs))
  mrs_only <- glm(event~mrs, data=dat, subset=testset)
  frs_only <- glm(event~frs, data=dat, subset=testset)
  combined <- glm(event~mrs+frs, data=dat, subset=testset)
  list(mrs=mrs_only, frs=frs_only, combined=combined, testset=testset)
}

lr_res <- run_mrs_lr(non_meth_data, varRes.list[[3]]$values)
mrs_ROC <- roc(non_meth_data$event[lr_res$testset], predict(lr_res$mrs))
plot(mrs_ROC, col="red")
frs_ROC <- roc(non_meth_data$event[lr_res$testset], predict(lr_res$frs))
plot(frs_ROC, col="blue", add=T)
combined_ROC <- roc(non_meth_data$event[lr_res$testset], predict(lr_res$combined))
plot(combined_ROC, col="green", add=T)
legend("bottomright", 
       legend=paste0(c("MRS: auc=", "FRS: auc=", "MRS+FRS: auc="), 
                     round(as.numeric(c(mrs_ROC$auc, frs_ROC$auc, 
                                        combined_ROC$auc)), 2)), 
       col=c("blue", "red", "green"), lty=1, lwd=3, cex=1.3)
```

## Final MRS construction and characterization

```{r final-model, cache=1}
final_design_mat <- construct_design_mat(marginal_res$CpG[1:2000],
                                         betas_all, "batch", nmd_all)

cl <- makePSOCKcluster(10)
registerDoParallel(cl)

final_mrs_fit <- train_glmnet(final_design_mat,
                              cvd_surv_all,
                              alpha=0, nfolds=10)

stopCluster(cl)
```

```{r final-model-characterization, message=F, warning=F}
final_coefs <- final_mrs_fit$cpg_coefs

mrs_final <- calc_mrs_glmnet(final_coefs, betas_all)

top_coefs <- final_coefs[abs(final_coefs) > 0.25]

gsa_tbl <- missMethyl::gometh(as.vector(names(top_coefs)), 
                              all.cpg=anno_450k$Name, collection="GO")

coef_hist <- ggplot(tibble(coef=final_coefs), aes(x=coef)) +
  geom_histogram() +
  labs(x="CpG weight in MRS")
coef_hist_highvals <- ggplot(tibble(coef=top_coefs), aes(x=coef)) +
  geom_histogram()

coef_hist
```

### MRS stability

```{r mrs-stability, cache=1, cache.vars=c("meta_lbc36_with_dups", "icc_res")}
betas_fhs_with_dups <- readRDS("../int/betas.qc.norm.filt_fhs.rds")
meta_fhs_with_dups <- readRDS("../int/metaData.rds") %>%
  filter(study == "fhs",
         sampleKey %in% colnames(betas_fhs_with_dups)) %>%
  group_by(subjID) %>%
  filter(n() > 1) %>%
  ungroup()
betas_fhs_with_dups <- betas_fhs_with_dups[, meta_fhs_with_dups$sampleKey]
meta_fhs_with_dups$mrs <- calc_mrs_glmnet(final_mrs_fit$cpg_coefs,
                                          betas_fhs_with_dups)
icc_res_fhs <- ICCest(x=subjID, y=mrs, data=meta_fhs_with_dups)

betas_lbc36_with_dups <- readRDS("../int/betas.qc.norm.filt_lbc.rds")
meta_lbc36_with_dups <- readRDS("../int/metaData.rds") %>%
  filter(study == "lbc36",
         sampleKey %in% colnames(betas_lbc36_with_dups))
betas_lbc36_with_dups <- betas_lbc36_with_dups[, meta_lbc36_with_dups$sampleKey]
meta_lbc36_with_dups$mrs <- calc_mrs_glmnet(final_mrs_fit$cpg_coefs, 
                                            betas_lbc36_with_dups)
icc_res_lbc36 <- ICCest(x=subjID, y=mrs, data=meta_lbc36_with_dups)

icc_res_tbl <- tibble(Cohort=c("FHS", "LBC36"),
                      Group_type=c("Duplicates", "Samples over multiple visits"),
                      ICC=c(icc_res_fhs$ICC, icc_res_lbc36$ICC))

kable(icc_res_tbl, caption="MRS stability as evaluated by using multiple within-subject measurements. Generic ICC heuristics for reference: 0-0.5 = poor, 0.5-0.75 = moderate, 0.75 - 0.9 = good, 0.9-1 = excellent.")
```

## Risk score interactions with demographic and risk-based attributes

The following set of results is based on models adjusting for age, sex (when not the stratifying factor), and cell counts.

```{r strat-helpers}
test_mrs_with_SE <- function(nmd, mrs, subset, covars) {
  test_res_list <- test_mrs(nmd, mrs, subset=subset, return_fit=T,
                            covars=covars)
  res_tbl <- test_res_list$tbl
  beta <- log(res_tbl$HR_per_SD)
  se <- sqrt(diag(test_res_list$fit$var)[1])
  res_tbl$SE_lower <- exp(beta - se)
  res_tbl$SE_higher <- exp(beta + se)
  res_tbl$n <- test_res_list$fit$n
  res_tbl
}

basic_covars <- c("age", "sex", "CD4T", "CD8T", "Bcell", 
                  "NK", "Mono", "Gran")

strat_test_by_study <- function(df, test_mrs, quantile_cat) {
  if (is.factor(df[[quantile_cat]])) {
    unique_levels <- na.omit(levels(df[[quantile_cat]]))
  } else {
    unique_levels <- na.omit(unique(df[[quantile_cat]]))
  }
  df$mrs <- test_mrs
  full_res <- map_dfr(unique_levels, function(q) {
    res_per_study <- df %>%
      nest(-study) %>%
      mutate(res=map(data, function(d) {
        tryCatch(test_mrs_with_SE(d, d$mrs, d[[quantile_cat]] == q,
                                  basic_covars[basic_covars != "sex"]),
                 error=function(e) data.frame(NA, NA, NA, NA))
      }))
    res_all <- test_mrs_with_SE(df, df$mrs, df[[quantile_cat]] == q,
                                basic_covars[basic_covars != "sex"])
    cbind(study=c(res_per_study$study, "all"), 
          bind_rows(bind_rows(res_per_study$res), res_all))
  }, .id="Group")
  full_res$Group <- unique_levels[as.numeric(full_res$Group)]
  full_res
}

plot_strat_test_by_study <- function(qres, xlab) {
  ggplot(qres, aes(x=Group, y=HR_per_SD, group=study, color=study)) +
    geom_point(position=position_dodge(width=0.25)) +
    geom_errorbar(aes(ymin=SE_lower, ymax=SE_higher), width=0,
                  position=position_dodge(width=0.25)) +
    labs(x=xlab)
}
```

### Demographics

* Sex (noting that the training set was considerably skewed towards females)
* Race
* Age

### Traditional risk

Framingham Risk Score (2008 generalized CVD version) was used to calculate cardiovascular risk. Diabetes was defined as either blood sugar medication use or measured fasting glucose > 125 mg/dL.

```{r calc-frs, message=F, warning=F}
source("helpers.R")

nmd_all$diabetes <- nmd_all$dm_med | (nmd_all$glu > 125)
nmd_all <- replace_na(nmd_all, list(diabetes=F, ht_med=F, smk_now=F))
nmd_all$frs <- calc_FRS(nmd_all)
```

```{r test-frs, warning=F}
test_frs <- function(frs_df) {
  # frs_df input should have both event data and a column names "frs"
  frs_df$frs <- scale(frs_df$frs)
  cvd_surv <- Surv(frs_df$time, frs_df$event)
  frs_test <- coxph(cvd_surv ~ frs, data=frs_df)
  frs_res <- summary(frs_test)$coef["frs", c("exp(coef)", "z")]
  frs_res_tbl <- tibble(HR_per_SD=frs_res["exp(coef)"], 
                        p=2 * pnorm(-abs(frs_res["z"])))
  frs_res_tbl
}

frs_res_tbl <- test_frs(nmd_all)
```

### Genetic risk

A genetic risk score (GRS) was calculated based on the genome-wide polygenic model used by Khera et al. 2018 for prediction of coronary heart disease (~6M SNPs). This GRS was first tested to confirm its associations in WHI and FHS (both of which had about 80% of the full set of GRS SNPs available after imputation and QC; table in Supplementary Info). While all CVD cases are incident in WHI, past and incident events were merged into a single binary variable for FHS in order to test the GRS.

```{r calc-grs, message=F, warning=F}
read_sscore <- function(filename) {
  read_tsv(filename) %>%
    dplyr::rename(subjID=IID,
                  grs=SCORE1_AVG) %>%
    mutate(grs=grs * 1e6) %>%  # So values are more reasonable
    select(subjID, grs)
}

grs_whi <- read_sscore("../int/whi_grs.sscore")
nmd_whi <- left_join(nmd_whi, grs_whi, by="subjID", suffix=c("",".2"))

# grs_fhs <- read_sscore("../int/fhs_grs.sscore") %>%
# grs_fhs <- read_sscore("../int/fhs_scores_nofilter.sscore") %>%
grs_fhs <- read_sscore("../int/test2.sscore") %>%
  mutate(subjID=as.character(subjID))
nmd_fhs <- left_join(nmd_fhs, grs_fhs, by="subjID", suffix=c("",".2"))

nmd_all <- left_join(nmd_all, rbind(grs_whi, grs_fhs),
                         by="subjID", suffix=c("",".2"))

grs_quantiles_fhs <- quantile(nmd_all$grs[nmd_all$study == "fhs"], 
                              seq(0, 1, by=0.2), na.rm=T)
grs_quantiles_whi <- quantile(nmd_all$grs[nmd_all$study =="whi"],
                              seq(0, 1, by=0.2), na.rm=T)
# source("helpers.R")
# 
# genotype.df.fhs <- read_table2("../int/grs_genos/grs_genos_fhs.vcf", skip=6)
# grs_df.fhs <- tibble(subjID=as.character(colnames(genotype.df.fhs)[-(1:9)]),
#                      grs=calc_khera2016grs(genotype.df.fhs))
# 
# genotype.df.whi <- read_table2("../int/grs_genos/grs_genos_whi.vcf", skip=6)
# imputedSampleInfo_whi <- read_tsv("../data/whi/gen/imputedSampleInfo.txt", skip=15)
# grs.ids.whi <- imputedSampleInfo_whi$SubjectID[match(colnames(genotype.df.whi)[-(1:9)],
#                                                      imputedSampleInfo_whi$SampleID)]
# 
# grs_df.whi <- tibble(subjID=as.character(grs.ids.whi), 
#                      grs=calc_khera2016grs(genotype.df.whi))
# 
# grs_df <- bind_rows(grs_df.fhs, grs_df.whi)
# 
# # genotype.df <- read_csv("../int/cvd_grs_genos.csv")
# # genotype.mat <- as.matrix(genotype.df[-1])
# # grs_df <- tibble(subjID=as.character(genotype.df[[1]]), grs=calc_khera2016grs(genotype.mat))
```

```{r test-grs, warning=F}
whi_grs_test_df <- nmd_whi
grs_res_whi <- test_grs(whi_grs_test_df)

fhs_grs_test_df <- mutate(nmd_fhs, event=pastEvent | event)
grs_res_fhs <- test_grs(fhs_grs_test_df)
```

### Stratified plots

```{r all-strats, fig.asp=1.4, warning=F}
# nmd_all$frs <- ifelse(nmd_all$study == "lbc36",
#                       nmd_lbc$frs[match(nmd_all$subjID, nmd_lbc$subjID)],
#                       nmd_whiFhs$frs[match(nmd_all$subjID, nmd_whiFhs$subjID)])
# nmd_all$grs <- nmd_whiFhs$grs[match(nmd_all$subjID, 
#                                     nmd_whiFhs$subjID)]

nmd_all$frs_group <- cut(nmd_all$frs,
                         breaks=c(0, 0.1, 0.2, 0.4, 1),
                         # breaks=quantile(nmd_all$frs, seq(0, 1, 0.2), na.rm=T),
                         # labels=c("0-0.1", "0.1-0.2", "0.2-0.3",
                         #          "0.3-0.4", "0.4+"),
                               include.lowest=T)
nmd_all$age_group <- cut(nmd_all$age,
                         breaks=c(0,55,65,75,100),
                         #labels=c("<55", "55-65", "65-75", ">75"),
                         # breaks=quantile(nmd_all$age, seq(0, 1, 0.2)),
                         include.lowest=T)

nmd_all$grs_group <- ifelse(nmd_all$study =="fhs",
                               cut(nmd_all$grs,
                                   breaks=grs_quantiles_fhs,
                                   labels=paste0("Q", 1:5),
                                   include.lowest=T),
                               cut(nmd_all$grs,
                                   breaks=grs_quantiles_whi,
                                   labels=paste0("Q", 1:5),
                                   include.lowest=T))

age_quantile_res <- strat_test_by_study(nmd_all, mrs_final, "age_group") %>%
  mutate(Group=factor(Group, levels=unique(Group)))
frs_quantile_res <- strat_test_by_study(nmd_all, mrs_final, "frs_group") %>%
  mutate(Group=factor(Group, levels=unique(Group)))
grs_quantile_res <- strat_test_by_study(nmd_all, mrs_final, "grs_group")
race_res <- strat_test_by_study(nmd_all, mrs_final, "race")
sex_res <- strat_test_by_study(nmd_all, mrs_final, "sex")
past_event_res <- strat_test_by_study(nmd_all, mrs_final, "pastEvent")

age_quantile_plt <- plot_strat_test_by_study(age_quantile_res, "Age") +
  theme(axis.text.x=element_text(angle=30))
frs_quantile_plt <- plot_strat_test_by_study(frs_quantile_res, "FRS 10-yr risk") +
  theme(axis.text.x=element_text(angle=30))
grs_quantile_plt <- plot_strat_test_by_study(grs_quantile_res, "Genetic risk score")
race_plt <- plot_strat_test_by_study(race_res, "Race")
sex_plt <- plot_strat_test_by_study(sex_res, "Sex")
past_event_plt <- plot_strat_test_by_study(past_event_res, "Past event")

plot_grid(sex_plt, race_plt, age_quantile_plt, 
          frs_quantile_plt, grs_quantile_plt, past_event_plt, nrow=3)
```


## Replication in REGICOR

* Age & sex-balanced but not incident and MI only
* Have already verified that a risk score trained in WHI & FHS discriminates between cases and controls fairly well
* Look for sex, age, and FRS interactions here

## Replication in InCHIANTI

* Will a cohort of ~600 be large enough?
* Look for sex, age, FRS, and genetic interactions here




<!--
# Exploration of model variants

To facilitate exploration of binary classifiers, testing from this point on uses logistic regression/odds ratios to evaluate MRS performance rather than Cox regression/hazard ratios. The CpG set used is still the 75th quantile variance threshold set.

```{r binary-funcs, eval=F}
train_mrs_binary <- function(mod, meta, meth, trainset, 
alpha=0.5, nfolds=5, lmr=0.1, lambda.type="lambda.min", parallel=F) {
covars_frame <- model.frame(as.formula(mod), meta, na.action=na.pass)  # To allow NAs to pass through
covars_mat <- model.matrix(as.formula(mod), covars_frame)[,-1]  # Converts factors to numeric
design_mat <- cbind(covars_mat, t(meth))
eventVec <- factor(meta$event)
mrs_fit_cv <- cv.glmnet(design_mat[trainset,], eventVec[trainset], family="binomial", alpha=alpha,
penalty.factor=ifelse(grepl("^cg", colnames(design_mat)), 1, 0), 
nfolds=nfolds, lambda.min.ratio=lmr, parallel=parallel)
coefs <- coef(mrs_fit_cv, s=lambda.type)
cpg_coefs <- coefs[grepl("^cg", rownames(coefs)),]
list(fit=mrs_fit_cv,  # Output is a list containing the model fit and the CpG model coefficients
all_coefs=coefs,
cpg_coefs=cpg_coefs)
}

test_mrs_binary <- function(meta, mrs, testset) {
meta$mrs <- scale(mrs)
mrs_test <- glm(event~mrs, data=meta, family="binomial", subset=testset) # Test the MRS using a Cox model
res <- summary(mrs_test)$coef["mrs",c("Estimate","Pr(>|z|)")]  # Outputs a vector
tibble(OR_per_SD=exp(res["Estimate"]), p=res["Pr(>|z|)"])
}

trainTestMRS_binary <- function(mod, meta, meth, trainset, testset, alpha=0.5, nfolds=5, lmr=0.1, lt="lambda.min", parallel=F) {
mrs_fit <- train_mrs_binary(mod, meta, meth, trainset, 
alpha=alpha, nfolds=nfolds, lmr=lmr, lambda.type=lt, parallel=parallel)
mrs_values <- calc_mrs(mrs_fit$cpg_coefs, meth)
mrs_test <- tryCatch(test_mrs_binary(meta, mrs_values, testset), error=function(e) matrix(NA, 1, 2))
list(fit=mrs_fit, components=mrs_fit$cpg_coefs, values=mrs_values, res=mrs_test)
}
```

```{r binary-test-baseline, eval=F}
binTestOnlyRes <- test_mrs_binary(non_meth_data, varRes.list[[3]]$values, fhsSet)
```

```{r binary-mrs, dependson="binary-funcs", eval=F}
cl <- makePSOCKcluster(4)
registerDoParallel(cl)
binaryModel <- trainTestMRS_binary(cpacor_adj_model, non_meth_data, 
logit2(betas[beta_variances>quantile(beta_variances,0.75),]),
whiSet, fhsSet, parallel=T)
stopCluster(cl)

binaryRes <- binaryModel$res
```

```{r display-binary-tests, dependson=c("binary-test-baseline","binary-mrs"), eval=F}
kable(mutate(binTestOnlyRes, p=as.character(format(p,digits=3))), caption="Test the same 75th quantile MRS from above for binary CVD event outcome")
kable(mutate(binaryRes, p=as.character(format(p,digits=3))), caption="Training and testing using a binary outcome")
```

```{r Mvals, eval=F}
cl <- makePSOCKcluster(4)
registerDoParallel(cl)
mvalModel <- trainTestMRS(cpacor_adj_model, non_meth_data, 
logit2(betas[beta_variances>quantile(beta_variances,0.75),]),
whiSet, fhsSet, parallel=T)
stopCluster(cl)

mvalRes_binTest <- test_mrs_binary(non_meth_data, mvalModel$values, fhsSet)
```

## Biological covariates

The intent to this point was to determine the "maximum predictive power" of microarray-based methylation data in predicting CVD events. However, known associations of methylation with sex, age, white blood cell proportions, etc. may explain a substantial fraction of this predictive power. 

```{r biological-significance, cache=F, eval=F}
wbcCounts <- dplyr::select(non_meth_data, CD4T, CD8T, Bcell, NK, Mono, Gran)
non_meth_data$wbcPC1 <- prcomp(wbcCounts, scale.=T)$x[,1]
non_meth_data$wbcPC2 <- prcomp(wbcCounts, scale.=T)$x[,2]

singleCovs <- c("sex","age","bmi","wbcPC1","wbcPC2","smk_now","ht_med","lipid_med","dm_med")
covs <- c("none", singleCovs, paste0(singleCovs, collapse="+"))
names(covs) <- c(covs[1:(length(covs)-1)], "all")
negLogPs <- lapply(covs, function (covSet) {
mrs <- enetCombined$values
form <- if (covSet == "none") as.formula("event~mrs") else as.formula(paste0("event~mrs+",covSet))
mrsCovs.fit <- glm(form, family="binomial", data=non_meth_data, subset=testset)
negLogP <- -log10(2*pnorm(-abs(summary(mrsCovs.fit)$coef["mrs","z value"])))
negLogP
})

negLogPs.df <- data.frame(covariate=factor(names(covs), levels=names(covs)), negLogP=unlist(negLogPs))

ggplot(negLogPs.df, aes(x=covariate, y="", fill=negLogP)) + 
geom_tile() +
scale_fill_gradient2(low='#0000FF',mid='#FFFFFF',high='#FF0000') +
coord_fixed(ratio=1) +
ggtitle("P-values for MRS after adjustment for covariate(s)") +
theme(axis.title=element_blank(), axis.text.x=element_text(angle=30))

non_meth_data$mrs <- enetCombined$values
mrs_resids <- lm(as.formula(paste0("mrs~",covs["all"])), data=non_meth_data)$residuals
adjROC <- roc(non_meth_data$event[testset], mrs_resids[testset])
```







# Alternate prediction strategies-

```{r gene-set-activations_old, eval=F}
msigdb_file <- file("../data/misc/gsea/c2.cp.v6.0.symbols.gmt")  # MSigDB file from http://software.broadinstitute.org/gsea/msigdb/collections.jsp#C2
msigdb <- strsplit(readLines(msigdb_file), split="\t")  # File is tab-separated with gene lists immediately following their names and URLs
names(msigdb) <- purrr::map(msigdb, 1)  # First element of each msig vector is name
msigdb <- purrr::map(msigdb, function(sig) sig[-c(1,2)])  # No need for name or URL

library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
annot <- data.frame(getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19), stringsAsFactors=F)
genes_to_cpgs_df <- annot %>%
dplyr::rename(gene=UCSC_RefGene_Name, cpg=Name) %>%
select(gene, cpg) %>%
separate_rows(gene, sep=";") %>%
distinct() %>% 
filter(!is.na(gene), gene!="") %>%
nest(-gene) %>%
mutate(cpgs=purrr::map(data, function(d) unique(d$cpg))) %>%
select(-data)
genes_to_cpgs <- setNames(genes_to_cpgs_df$cpgs, genes_to_cpgs_df$gene)  # List of associated CpGs on 450k array for each gene

sig_to_cpgs <- purrr::map(msigdb, function(sig) unique(unlist(genes_to_cpgs[sig])))

library(flashpcaR)

pca_from_cpg_set <- function(cpgs) {
cpgs_trimmed <- cpgs[cpgs %in% rownames(betas)]
pcaMat <- t(betas[cpgs_trimmed,])
pca.fit <- flashpca(pcaMat, stand="sd", ndim=2, do_loadings=T)
pc1_loadings <- pca.fit$loadings[,1]
setNames(pc1_loadings, cpgs_trimmed)
}

geneSetLoadings <- lapply(sig_to_cpgs, pca_from_cpg_set)

t_betas_scaled <- scale(t(betas))
geneSetActivations <- lapply(geneSetLoadings, function(loading) t_betas_scaled[,names(loading)] %*% loading)
geneSetActivationsMat <- do.call(cbind, geneSetActivations)
colnames(geneSetActivationsMat) <- names(geneSetActivations)
```

```{r hypothesis-driven, eval=F}
# See how pre-selection of specific CpG sets affects model performance
print("Test pre-selected CpG sets with biological relevance...")
library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
mon_to_mac <- suppressWarnings(read_csv("../data/literature/mon_to_mac_DMRs_Wallner2016.csv")) %>%
filter(!is.na(Location)) %>%
mutate(chr=gsub(":.*", "", Location),
start=as.integer(gsub("-.*", "", gsub(".*:", "", Location))),
end=as.integer(gsub(".*-", "", Location))) %>%
select(chr, start, end)

mon_var_schroder <- read_csv("../data/literature/variable_monocyte_DMRs_Schroder2017.csv") %>%
mutate(chr=paste0("chr", gsub(":.*", "", location)),
start=as.integer(gsub("-.*", "", gsub(".*:", "", location))),
end=as.integer(gsub(".*-", "", location))) %>%
select(chr, start, end)

cpgAnnot <- Locations %>%
data.frame(stringsAsFactors=F) %>%
rownames_to_column(var="cpg")

mon_to_mac_cpgs <- inner_join(cpgAnnot, mon_to_mac, by="chr") %>%
filter(pos>=start, pos<=end)

mon_var_schroder_cpgs <- inner_join(cpgAnnot, mon_var_schroder, by="chr") %>%
filter(pos>=start, pos<=end)

# Read in Ecker variable CpGs (more than one sheet, each separately)
library(readxl)
variable_monSpecific <- read_excel("../data/literature/variable_cpgs_Ecker2017.xlsx", sheet="Monocytes")
variable_neutSpecific <- read_excel("../data/literature/variable_cpgs_Ecker2017.xlsx", sheet="Neutrophils")
variable_tcellSpecific <- read_excel("../data/literature/variable_cpgs_Ecker2017.xlsx", sheet="T cells")
variable_monNeutSpecific <- read_excel("../data/literature/variable_cpgs_Ecker2017.xlsx",
sheet="Monocytes + neutrophils")

trainTest_cpg_set <- function(cpg_set, cpg_setName) {
print(paste0(cpg_setName, " (", length(cpg_set), " CpGs)"))
kable(trainTestMRS(cpacor_adj_model, non_meth_data, betas[rownames(betas) %in% cpg_set,],
whiSet, fhsSet)$res)
}

trainTest_cpg_set(mon_to_mac_cpgs$cpg, "Monocyte-to-macrophage DMRs, Wallner 2016")
trainTest_cpg_set(mon_var_schroder_cpgs$cpg, "Variable CpGs in monocytes, Schroder 2017")
trainTest_cpg_set(variable_monSpecific$`Probe ID`, "Variable CpGs in monocytes only, Ecker 2017")
trainTest_cpg_set(variable_neutSpecific$`Probe ID`, "Variable CpGs in neutrophils only, Ecker 2017")
trainTest_cpg_set(variable_tcellSpecific$`Probe ID`, "Variable CpGs in T-cells only, Ecker 2017")
trainTest_cpg_set(variable_monNeutSpecific$`Probe ID`, "Variable CpGs in monocytes and neutrophils only, Ecker 2017")
trainTest_cpg_set(cvd_gwas_cpgs_by_pos$cpg, "CpGs +/- 1kb from GWAS catalog CVD SNPs")
trainTest_cpg_set(cvd_gwas_cpgs_byGene$cpg, 
"CpGs annotated to genes to which GWAS catalog CVD SNPs are annotated")
```
-->
